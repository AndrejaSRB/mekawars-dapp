"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

type AddCrewToBucket {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  bucketIndex: BigInt!
  crewId: BigInt!
  id: Bytes!
  transactionHash: Bytes!
}

input AddCrewToBucket_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [AddCrewToBucket_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  bucketIndex: BigInt
  bucketIndex_gt: BigInt
  bucketIndex_gte: BigInt
  bucketIndex_in: [BigInt!]
  bucketIndex_lt: BigInt
  bucketIndex_lte: BigInt
  bucketIndex_not: BigInt
  bucketIndex_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [AddCrewToBucket_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum AddCrewToBucket_orderBy {
  blockNumber
  blockTimestamp
  bucketIndex
  crewId
  id
  transactionHash
}

type AddItemToInventory {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  itemId: BigInt!
  itemIndexInInventory: BigInt!
  transactionHash: Bytes!
}

input AddItemToInventory_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [AddItemToInventory_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  itemId: BigInt
  itemId_gt: BigInt
  itemId_gte: BigInt
  itemId_in: [BigInt!]
  itemId_lt: BigInt
  itemId_lte: BigInt
  itemId_not: BigInt
  itemId_not_in: [BigInt!]
  itemIndexInInventory: BigInt
  itemIndexInInventory_gt: BigInt
  itemIndexInInventory_gte: BigInt
  itemIndexInInventory_in: [BigInt!]
  itemIndexInInventory_lt: BigInt
  itemIndexInInventory_lte: BigInt
  itemIndexInInventory_not: BigInt
  itemIndexInInventory_not_in: [BigInt!]
  or: [AddItemToInventory_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum AddItemToInventory_orderBy {
  blockNumber
  blockTimestamp
  crewId
  id
  itemId
  itemIndexInInventory
  transactionHash
}

type AddRoboToCrew {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  roboId: BigInt!
  transactionHash: Bytes!
}

input AddRoboToCrew_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [AddRoboToCrew_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [AddRoboToCrew_filter]
  roboId: BigInt
  roboId_gt: BigInt
  roboId_gte: BigInt
  roboId_in: [BigInt!]
  roboId_lt: BigInt
  roboId_lte: BigInt
  roboId_not: BigInt
  roboId_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum AddRoboToCrew_orderBy {
  blockNumber
  blockTimestamp
  crewId
  id
  roboId
  transactionHash
}

type Approval {
  approved: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  owner: Bytes!
  tokenId: BigInt!
  transactionHash: Bytes!
}

type ApprovalForAll {
  approved: Boolean!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  operator: Bytes!
  owner: Bytes!
  transactionHash: Bytes!
}

input ApprovalForAll_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ApprovalForAll_filter]
  approved: Boolean
  approved_in: [Boolean!]
  approved_not: Boolean
  approved_not_in: [Boolean!]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  operator: Bytes
  operator_contains: Bytes
  operator_gt: Bytes
  operator_gte: Bytes
  operator_in: [Bytes!]
  operator_lt: Bytes
  operator_lte: Bytes
  operator_not: Bytes
  operator_not_contains: Bytes
  operator_not_in: [Bytes!]
  or: [ApprovalForAll_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum ApprovalForAll_orderBy {
  approved
  blockNumber
  blockTimestamp
  id
  operator
  owner
  transactionHash
}

input Approval_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Approval_filter]
  approved: Bytes
  approved_contains: Bytes
  approved_gt: Bytes
  approved_gte: Bytes
  approved_in: [Bytes!]
  approved_lt: Bytes
  approved_lte: Bytes
  approved_not: Bytes
  approved_not_contains: Bytes
  approved_not_in: [Bytes!]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [Approval_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  tokenId: BigInt
  tokenId_gt: BigInt
  tokenId_gte: BigInt
  tokenId_in: [BigInt!]
  tokenId_lt: BigInt
  tokenId_lte: BigInt
  tokenId_not: BigInt
  tokenId_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum Approval_orderBy {
  approved
  blockNumber
  blockTimestamp
  id
  owner
  tokenId
  transactionHash
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

type BoxInitialized {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  transactionHash: Bytes!
  version: Int!
}

input BoxInitialized_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [BoxInitialized_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [BoxInitialized_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  version: Int
  version_gt: Int
  version_gte: Int
  version_in: [Int!]
  version_lt: Int
  version_lte: Int
  version_not: Int
  version_not_in: [Int!]
}

enum BoxInitialized_orderBy {
  blockNumber
  blockTimestamp
  id
  transactionHash
  version
}

type BoxOpened {
  NTWon: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  itemsWon: [BigInt!]!
  newSlotState: Int!
  slotIndex: BigInt!
  transactionHash: Bytes!
}

input BoxOpened_filter {
  NTWon: BigInt
  NTWon_gt: BigInt
  NTWon_gte: BigInt
  NTWon_in: [BigInt!]
  NTWon_lt: BigInt
  NTWon_lte: BigInt
  NTWon_not: BigInt
  NTWon_not_in: [BigInt!]

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [BoxOpened_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  itemsWon: [BigInt!]
  itemsWon_contains: [BigInt!]
  itemsWon_contains_nocase: [BigInt!]
  itemsWon_not: [BigInt!]
  itemsWon_not_contains: [BigInt!]
  itemsWon_not_contains_nocase: [BigInt!]
  newSlotState: Int
  newSlotState_gt: Int
  newSlotState_gte: Int
  newSlotState_in: [Int!]
  newSlotState_lt: Int
  newSlotState_lte: Int
  newSlotState_not: Int
  newSlotState_not_in: [Int!]
  or: [BoxOpened_filter]
  slotIndex: BigInt
  slotIndex_gt: BigInt
  slotIndex_gte: BigInt
  slotIndex_in: [BigInt!]
  slotIndex_lt: BigInt
  slotIndex_lte: BigInt
  slotIndex_not: BigInt
  slotIndex_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum BoxOpened_orderBy {
  NTWon
  blockNumber
  blockTimestamp
  crewId
  id
  itemsWon
  newSlotState
  slotIndex
  transactionHash
}

type BoxRoleAdminChanged {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  newAdminRole: Bytes!
  previousAdminRole: Bytes!
  role: Bytes!
  transactionHash: Bytes!
}

input BoxRoleAdminChanged_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [BoxRoleAdminChanged_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  newAdminRole: Bytes
  newAdminRole_contains: Bytes
  newAdminRole_gt: Bytes
  newAdminRole_gte: Bytes
  newAdminRole_in: [Bytes!]
  newAdminRole_lt: Bytes
  newAdminRole_lte: Bytes
  newAdminRole_not: Bytes
  newAdminRole_not_contains: Bytes
  newAdminRole_not_in: [Bytes!]
  or: [BoxRoleAdminChanged_filter]
  previousAdminRole: Bytes
  previousAdminRole_contains: Bytes
  previousAdminRole_gt: Bytes
  previousAdminRole_gte: Bytes
  previousAdminRole_in: [Bytes!]
  previousAdminRole_lt: Bytes
  previousAdminRole_lte: Bytes
  previousAdminRole_not: Bytes
  previousAdminRole_not_contains: Bytes
  previousAdminRole_not_in: [Bytes!]
  role: Bytes
  role_contains: Bytes
  role_gt: Bytes
  role_gte: Bytes
  role_in: [Bytes!]
  role_lt: Bytes
  role_lte: Bytes
  role_not: Bytes
  role_not_contains: Bytes
  role_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum BoxRoleAdminChanged_orderBy {
  blockNumber
  blockTimestamp
  id
  newAdminRole
  previousAdminRole
  role
  transactionHash
}

type BoxRoleGranted {
  account: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  role: Bytes!
  sender: Bytes!
  transactionHash: Bytes!
}

input BoxRoleGranted_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [BoxRoleGranted_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [BoxRoleGranted_filter]
  role: Bytes
  role_contains: Bytes
  role_gt: Bytes
  role_gte: Bytes
  role_in: [Bytes!]
  role_lt: Bytes
  role_lte: Bytes
  role_not: Bytes
  role_not_contains: Bytes
  role_not_in: [Bytes!]
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum BoxRoleGranted_orderBy {
  account
  blockNumber
  blockTimestamp
  id
  role
  sender
  transactionHash
}

type BoxRoleRevoked {
  account: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  role: Bytes!
  sender: Bytes!
  transactionHash: Bytes!
}

input BoxRoleRevoked_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [BoxRoleRevoked_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [BoxRoleRevoked_filter]
  role: Bytes
  role_contains: Bytes
  role_gt: Bytes
  role_gte: Bytes
  role_in: [Bytes!]
  role_lt: Bytes
  role_lte: Bytes
  role_not: Bytes
  role_not_contains: Bytes
  role_not_in: [Bytes!]
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum BoxRoleRevoked_orderBy {
  account
  blockNumber
  blockTimestamp
  id
  role
  sender
  transactionHash
}

type BoxSlot {
  babyOogaCharge: BigInt
  box_createdAt: BigInt
  box_level: BigInt
  box_rarity: Int
  crew: Crew
  id: String!
  index: BigInt
  stakedBabyOoga: Ooga
  state: Int
}

input BoxSlot_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [BoxSlot_filter]
  babyOogaCharge: BigInt
  babyOogaCharge_gt: BigInt
  babyOogaCharge_gte: BigInt
  babyOogaCharge_in: [BigInt!]
  babyOogaCharge_lt: BigInt
  babyOogaCharge_lte: BigInt
  babyOogaCharge_not: BigInt
  babyOogaCharge_not_in: [BigInt!]
  box_createdAt: BigInt
  box_createdAt_gt: BigInt
  box_createdAt_gte: BigInt
  box_createdAt_in: [BigInt!]
  box_createdAt_lt: BigInt
  box_createdAt_lte: BigInt
  box_createdAt_not: BigInt
  box_createdAt_not_in: [BigInt!]
  box_level: BigInt
  box_level_gt: BigInt
  box_level_gte: BigInt
  box_level_in: [BigInt!]
  box_level_lt: BigInt
  box_level_lte: BigInt
  box_level_not: BigInt
  box_level_not_in: [BigInt!]
  box_rarity: Int
  box_rarity_gt: Int
  box_rarity_gte: Int
  box_rarity_in: [Int!]
  box_rarity_lt: Int
  box_rarity_lte: Int
  box_rarity_not: Int
  box_rarity_not_in: [Int!]
  crew: String
  crew_: Crew_filter
  crew_contains: String
  crew_contains_nocase: String
  crew_ends_with: String
  crew_ends_with_nocase: String
  crew_gt: String
  crew_gte: String
  crew_in: [String!]
  crew_lt: String
  crew_lte: String
  crew_not: String
  crew_not_contains: String
  crew_not_contains_nocase: String
  crew_not_ends_with: String
  crew_not_ends_with_nocase: String
  crew_not_in: [String!]
  crew_not_starts_with: String
  crew_not_starts_with_nocase: String
  crew_starts_with: String
  crew_starts_with_nocase: String
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  index: BigInt
  index_gt: BigInt
  index_gte: BigInt
  index_in: [BigInt!]
  index_lt: BigInt
  index_lte: BigInt
  index_not: BigInt
  index_not_in: [BigInt!]
  or: [BoxSlot_filter]
  stakedBabyOoga: String
  stakedBabyOoga_: Ooga_filter
  stakedBabyOoga_contains: String
  stakedBabyOoga_contains_nocase: String
  stakedBabyOoga_ends_with: String
  stakedBabyOoga_ends_with_nocase: String
  stakedBabyOoga_gt: String
  stakedBabyOoga_gte: String
  stakedBabyOoga_in: [String!]
  stakedBabyOoga_lt: String
  stakedBabyOoga_lte: String
  stakedBabyOoga_not: String
  stakedBabyOoga_not_contains: String
  stakedBabyOoga_not_contains_nocase: String
  stakedBabyOoga_not_ends_with: String
  stakedBabyOoga_not_ends_with_nocase: String
  stakedBabyOoga_not_in: [String!]
  stakedBabyOoga_not_starts_with: String
  stakedBabyOoga_not_starts_with_nocase: String
  stakedBabyOoga_starts_with: String
  stakedBabyOoga_starts_with_nocase: String
  state: Int
  state_gt: Int
  state_gte: Int
  state_in: [Int!]
  state_lt: Int
  state_lte: Int
  state_not: Int
  state_not_in: [Int!]
}

enum BoxSlot_orderBy {
  babyOogaCharge
  box_createdAt
  box_level
  box_rarity
  crew
  id
  index
  stakedBabyOoga
  state
}

type BoxUpgraded {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  newRarity: Int!
  newSlotState: Int!
  slotIndex: BigInt!
  transactionHash: Bytes!
}

input BoxUpgraded_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [BoxUpgraded_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  newRarity: Int
  newRarity_gt: Int
  newRarity_gte: Int
  newRarity_in: [Int!]
  newRarity_lt: Int
  newRarity_lte: Int
  newRarity_not: Int
  newRarity_not_in: [Int!]
  newSlotState: Int
  newSlotState_gt: Int
  newSlotState_gte: Int
  newSlotState_in: [Int!]
  newSlotState_lt: Int
  newSlotState_lte: Int
  newSlotState_not: Int
  newSlotState_not_in: [Int!]
  or: [BoxUpgraded_filter]
  slotIndex: BigInt
  slotIndex_gt: BigInt
  slotIndex_gte: BigInt
  slotIndex_in: [BigInt!]
  slotIndex_lt: BigInt
  slotIndex_lte: BigInt
  slotIndex_not: BigInt
  slotIndex_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum BoxUpgraded_orderBy {
  blockNumber
  blockTimestamp
  crewId
  id
  newRarity
  newSlotState
  slotIndex
  transactionHash
}

type Bucket {
  createdAt: BigInt
  crewIds(
    first: Int = 100
    orderBy: CrewInBucket_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: CrewInBucket_filter
  ): [CrewInBucket!]
  id: String!
  randomSeed: BigInt
  resolvedMatches(
    first: Int = 100
    orderBy: Match_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Match_filter
  ): [Match!]!
  state: Int
}

input Bucket_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Bucket_filter]
  createdAt: BigInt
  createdAt_gt: BigInt
  createdAt_gte: BigInt
  createdAt_in: [BigInt!]
  createdAt_lt: BigInt
  createdAt_lte: BigInt
  createdAt_not: BigInt
  createdAt_not_in: [BigInt!]
  crewIds: [String!]
  crewIds_: CrewInBucket_filter
  crewIds_contains: [String!]
  crewIds_contains_nocase: [String!]
  crewIds_not: [String!]
  crewIds_not_contains: [String!]
  crewIds_not_contains_nocase: [String!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [Bucket_filter]
  randomSeed: BigInt
  randomSeed_gt: BigInt
  randomSeed_gte: BigInt
  randomSeed_in: [BigInt!]
  randomSeed_lt: BigInt
  randomSeed_lte: BigInt
  randomSeed_not: BigInt
  randomSeed_not_in: [BigInt!]
  resolvedMatches_: Match_filter
  state: Int
  state_gt: Int
  state_gte: Int
  state_in: [Int!]
  state_lt: Int
  state_lte: Int
  state_not: Int
  state_not_in: [Int!]
}

enum Bucket_orderBy {
  createdAt
  crewIds
  id
  randomSeed
  resolvedMatches
  state
}

type BuyMysteryBox {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  level: BigInt!
  transactionHash: Bytes!
}

input BuyMysteryBox_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [BuyMysteryBox_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  level: BigInt
  level_gt: BigInt
  level_gte: BigInt
  level_in: [BigInt!]
  level_lt: BigInt
  level_lte: BigInt
  level_not: BigInt
  level_not_in: [BigInt!]
  or: [BuyMysteryBox_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum BuyMysteryBox_orderBy {
  blockNumber
  blockTimestamp
  crewId
  id
  level
  transactionHash
}

scalar Bytes

type ChangeBucketState {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  bucketIndex: BigInt!
  id: Bytes!
  newBucketState: Int!
  transactionHash: Bytes!
}

input ChangeBucketState_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ChangeBucketState_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  bucketIndex: BigInt
  bucketIndex_gt: BigInt
  bucketIndex_gte: BigInt
  bucketIndex_in: [BigInt!]
  bucketIndex_lt: BigInt
  bucketIndex_lte: BigInt
  bucketIndex_not: BigInt
  bucketIndex_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  newBucketState: Int
  newBucketState_gt: Int
  newBucketState_gte: Int
  newBucketState_in: [Int!]
  newBucketState_lt: Int
  newBucketState_lte: Int
  newBucketState_not: Int
  newBucketState_not_in: [Int!]
  or: [ChangeBucketState_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum ChangeBucketState_orderBy {
  blockNumber
  blockTimestamp
  bucketIndex
  id
  newBucketState
  transactionHash
}

type ContractParameter {
  box_babyOogaChargeNeededForUpgrade: BigInt
  box_boxWaitingTime: BigInt
  box_instantOpenBoxPrice: BigInt
  crews_burnInventoryItemNTAmount: BigInt
  crews_crewStartDurability: BigInt
  id: String!
  matchmaking_durabilityDecrease: BigInt
  matchmaking_maxBucketSize: BigInt
  matchmaking_maxRatingDiff: BigInt
  matchmaking_minBucketSize: BigInt
  matchmaking_minTimeOffset: BigInt
}

input ContractParameter_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ContractParameter_filter]
  box_babyOogaChargeNeededForUpgrade: BigInt
  box_babyOogaChargeNeededForUpgrade_gt: BigInt
  box_babyOogaChargeNeededForUpgrade_gte: BigInt
  box_babyOogaChargeNeededForUpgrade_in: [BigInt!]
  box_babyOogaChargeNeededForUpgrade_lt: BigInt
  box_babyOogaChargeNeededForUpgrade_lte: BigInt
  box_babyOogaChargeNeededForUpgrade_not: BigInt
  box_babyOogaChargeNeededForUpgrade_not_in: [BigInt!]
  box_boxWaitingTime: BigInt
  box_boxWaitingTime_gt: BigInt
  box_boxWaitingTime_gte: BigInt
  box_boxWaitingTime_in: [BigInt!]
  box_boxWaitingTime_lt: BigInt
  box_boxWaitingTime_lte: BigInt
  box_boxWaitingTime_not: BigInt
  box_boxWaitingTime_not_in: [BigInt!]
  box_instantOpenBoxPrice: BigInt
  box_instantOpenBoxPrice_gt: BigInt
  box_instantOpenBoxPrice_gte: BigInt
  box_instantOpenBoxPrice_in: [BigInt!]
  box_instantOpenBoxPrice_lt: BigInt
  box_instantOpenBoxPrice_lte: BigInt
  box_instantOpenBoxPrice_not: BigInt
  box_instantOpenBoxPrice_not_in: [BigInt!]
  crews_burnInventoryItemNTAmount: BigInt
  crews_burnInventoryItemNTAmount_gt: BigInt
  crews_burnInventoryItemNTAmount_gte: BigInt
  crews_burnInventoryItemNTAmount_in: [BigInt!]
  crews_burnInventoryItemNTAmount_lt: BigInt
  crews_burnInventoryItemNTAmount_lte: BigInt
  crews_burnInventoryItemNTAmount_not: BigInt
  crews_burnInventoryItemNTAmount_not_in: [BigInt!]
  crews_crewStartDurability: BigInt
  crews_crewStartDurability_gt: BigInt
  crews_crewStartDurability_gte: BigInt
  crews_crewStartDurability_in: [BigInt!]
  crews_crewStartDurability_lt: BigInt
  crews_crewStartDurability_lte: BigInt
  crews_crewStartDurability_not: BigInt
  crews_crewStartDurability_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  matchmaking_durabilityDecrease: BigInt
  matchmaking_durabilityDecrease_gt: BigInt
  matchmaking_durabilityDecrease_gte: BigInt
  matchmaking_durabilityDecrease_in: [BigInt!]
  matchmaking_durabilityDecrease_lt: BigInt
  matchmaking_durabilityDecrease_lte: BigInt
  matchmaking_durabilityDecrease_not: BigInt
  matchmaking_durabilityDecrease_not_in: [BigInt!]
  matchmaking_maxBucketSize: BigInt
  matchmaking_maxBucketSize_gt: BigInt
  matchmaking_maxBucketSize_gte: BigInt
  matchmaking_maxBucketSize_in: [BigInt!]
  matchmaking_maxBucketSize_lt: BigInt
  matchmaking_maxBucketSize_lte: BigInt
  matchmaking_maxBucketSize_not: BigInt
  matchmaking_maxBucketSize_not_in: [BigInt!]
  matchmaking_maxRatingDiff: BigInt
  matchmaking_maxRatingDiff_gt: BigInt
  matchmaking_maxRatingDiff_gte: BigInt
  matchmaking_maxRatingDiff_in: [BigInt!]
  matchmaking_maxRatingDiff_lt: BigInt
  matchmaking_maxRatingDiff_lte: BigInt
  matchmaking_maxRatingDiff_not: BigInt
  matchmaking_maxRatingDiff_not_in: [BigInt!]
  matchmaking_minBucketSize: BigInt
  matchmaking_minBucketSize_gt: BigInt
  matchmaking_minBucketSize_gte: BigInt
  matchmaking_minBucketSize_in: [BigInt!]
  matchmaking_minBucketSize_lt: BigInt
  matchmaking_minBucketSize_lte: BigInt
  matchmaking_minBucketSize_not: BigInt
  matchmaking_minBucketSize_not_in: [BigInt!]
  matchmaking_minTimeOffset: BigInt
  matchmaking_minTimeOffset_gt: BigInt
  matchmaking_minTimeOffset_gte: BigInt
  matchmaking_minTimeOffset_in: [BigInt!]
  matchmaking_minTimeOffset_lt: BigInt
  matchmaking_minTimeOffset_lte: BigInt
  matchmaking_minTimeOffset_not: BigInt
  matchmaking_minTimeOffset_not_in: [BigInt!]
  or: [ContractParameter_filter]
}

enum ContractParameter_orderBy {
  box_babyOogaChargeNeededForUpgrade
  box_boxWaitingTime
  box_instantOpenBoxPrice
  crews_burnInventoryItemNTAmount
  crews_crewStartDurability
  id
  matchmaking_durabilityDecrease
  matchmaking_maxBucketSize
  matchmaking_maxRatingDiff
  matchmaking_minBucketSize
  matchmaking_minTimeOffset
}

type Crew {
  active: Boolean!
  boxSlots(
    first: Int = 100
    orderBy: BoxSlot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: BoxSlot_filter
  ): [BoxSlot!]!
  currentlyInBucket: Bucket
  durability: BigInt!
  firstTeam(
    first: Int = 100
    orderBy: Ooga_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Ooga_filter
  ): [Ooga!]!
  id: String!
  inventory(
    first: Int = 100
    orderBy: InventoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: InventoryItem_filter
  ): [InventoryItem!]
  level: BigInt
  mekaLeader: Ooga!
  ntAmount: BigInt
  oogasInCrew(
    first: Int = 100
    orderBy: Ooga_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Ooga_filter
  ): [Ooga!]
  owner: User!
  rating: BigInt!
}

type CrewInBucket {
  bucket: Bucket
  crew: Crew
  firstTeam(
    first: Int = 100
    orderBy: Ooga_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Ooga_filter
  ): [Ooga!]!
  id: String!
}

input CrewInBucket_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [CrewInBucket_filter]
  bucket: String
  bucket_: Bucket_filter
  bucket_contains: String
  bucket_contains_nocase: String
  bucket_ends_with: String
  bucket_ends_with_nocase: String
  bucket_gt: String
  bucket_gte: String
  bucket_in: [String!]
  bucket_lt: String
  bucket_lte: String
  bucket_not: String
  bucket_not_contains: String
  bucket_not_contains_nocase: String
  bucket_not_ends_with: String
  bucket_not_ends_with_nocase: String
  bucket_not_in: [String!]
  bucket_not_starts_with: String
  bucket_not_starts_with_nocase: String
  bucket_starts_with: String
  bucket_starts_with_nocase: String
  crew: String
  crew_: Crew_filter
  crew_contains: String
  crew_contains_nocase: String
  crew_ends_with: String
  crew_ends_with_nocase: String
  crew_gt: String
  crew_gte: String
  crew_in: [String!]
  crew_lt: String
  crew_lte: String
  crew_not: String
  crew_not_contains: String
  crew_not_contains_nocase: String
  crew_not_ends_with: String
  crew_not_ends_with_nocase: String
  crew_not_in: [String!]
  crew_not_starts_with: String
  crew_not_starts_with_nocase: String
  crew_starts_with: String
  crew_starts_with_nocase: String
  firstTeam: [String!]
  firstTeam_: Ooga_filter
  firstTeam_contains: [String!]
  firstTeam_contains_nocase: [String!]
  firstTeam_not: [String!]
  firstTeam_not_contains: [String!]
  firstTeam_not_contains_nocase: [String!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [CrewInBucket_filter]
}

enum CrewInBucket_orderBy {
  bucket
  crew
  firstTeam
  id
}

input Crew_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  active: Boolean
  active_in: [Boolean!]
  active_not: Boolean
  active_not_in: [Boolean!]
  and: [Crew_filter]
  boxSlots_: BoxSlot_filter
  currentlyInBucket: String
  currentlyInBucket_: Bucket_filter
  currentlyInBucket_contains: String
  currentlyInBucket_contains_nocase: String
  currentlyInBucket_ends_with: String
  currentlyInBucket_ends_with_nocase: String
  currentlyInBucket_gt: String
  currentlyInBucket_gte: String
  currentlyInBucket_in: [String!]
  currentlyInBucket_lt: String
  currentlyInBucket_lte: String
  currentlyInBucket_not: String
  currentlyInBucket_not_contains: String
  currentlyInBucket_not_contains_nocase: String
  currentlyInBucket_not_ends_with: String
  currentlyInBucket_not_ends_with_nocase: String
  currentlyInBucket_not_in: [String!]
  currentlyInBucket_not_starts_with: String
  currentlyInBucket_not_starts_with_nocase: String
  currentlyInBucket_starts_with: String
  currentlyInBucket_starts_with_nocase: String
  durability: BigInt
  durability_gt: BigInt
  durability_gte: BigInt
  durability_in: [BigInt!]
  durability_lt: BigInt
  durability_lte: BigInt
  durability_not: BigInt
  durability_not_in: [BigInt!]
  firstTeam: [String!]
  firstTeam_: Ooga_filter
  firstTeam_contains: [String!]
  firstTeam_contains_nocase: [String!]
  firstTeam_not: [String!]
  firstTeam_not_contains: [String!]
  firstTeam_not_contains_nocase: [String!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  inventory_: InventoryItem_filter
  level: BigInt
  level_gt: BigInt
  level_gte: BigInt
  level_in: [BigInt!]
  level_lt: BigInt
  level_lte: BigInt
  level_not: BigInt
  level_not_in: [BigInt!]
  mekaLeader: String
  mekaLeader_: Ooga_filter
  mekaLeader_contains: String
  mekaLeader_contains_nocase: String
  mekaLeader_ends_with: String
  mekaLeader_ends_with_nocase: String
  mekaLeader_gt: String
  mekaLeader_gte: String
  mekaLeader_in: [String!]
  mekaLeader_lt: String
  mekaLeader_lte: String
  mekaLeader_not: String
  mekaLeader_not_contains: String
  mekaLeader_not_contains_nocase: String
  mekaLeader_not_ends_with: String
  mekaLeader_not_ends_with_nocase: String
  mekaLeader_not_in: [String!]
  mekaLeader_not_starts_with: String
  mekaLeader_not_starts_with_nocase: String
  mekaLeader_starts_with: String
  mekaLeader_starts_with_nocase: String
  ntAmount: BigInt
  ntAmount_gt: BigInt
  ntAmount_gte: BigInt
  ntAmount_in: [BigInt!]
  ntAmount_lt: BigInt
  ntAmount_lte: BigInt
  ntAmount_not: BigInt
  ntAmount_not_in: [BigInt!]
  oogasInCrew_: Ooga_filter
  or: [Crew_filter]
  owner: String
  owner_: User_filter
  owner_contains: String
  owner_contains_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_gt: String
  owner_gte: String
  owner_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_not: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_not_in: [String!]
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  rating: BigInt
  rating_gt: BigInt
  rating_gte: BigInt
  rating_in: [BigInt!]
  rating_lt: BigInt
  rating_lte: BigInt
  rating_not: BigInt
  rating_not_in: [BigInt!]
}

enum Crew_orderBy {
  active
  boxSlots
  currentlyInBucket
  durability
  firstTeam
  id
  inventory
  level
  mekaLeader
  ntAmount
  oogasInCrew
  owner
  rating
}

type CrewsInitialized {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  transactionHash: Bytes!
  version: Int!
}

input CrewsInitialized_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [CrewsInitialized_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [CrewsInitialized_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  version: Int
  version_gt: Int
  version_gte: Int
  version_in: [Int!]
  version_lt: Int
  version_lte: Int
  version_not: Int
  version_not_in: [Int!]
}

enum CrewsInitialized_orderBy {
  blockNumber
  blockTimestamp
  id
  transactionHash
  version
}

type CrewsRoleAdminChanged {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  newAdminRole: Bytes!
  previousAdminRole: Bytes!
  role: Bytes!
  transactionHash: Bytes!
}

input CrewsRoleAdminChanged_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [CrewsRoleAdminChanged_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  newAdminRole: Bytes
  newAdminRole_contains: Bytes
  newAdminRole_gt: Bytes
  newAdminRole_gte: Bytes
  newAdminRole_in: [Bytes!]
  newAdminRole_lt: Bytes
  newAdminRole_lte: Bytes
  newAdminRole_not: Bytes
  newAdminRole_not_contains: Bytes
  newAdminRole_not_in: [Bytes!]
  or: [CrewsRoleAdminChanged_filter]
  previousAdminRole: Bytes
  previousAdminRole_contains: Bytes
  previousAdminRole_gt: Bytes
  previousAdminRole_gte: Bytes
  previousAdminRole_in: [Bytes!]
  previousAdminRole_lt: Bytes
  previousAdminRole_lte: Bytes
  previousAdminRole_not: Bytes
  previousAdminRole_not_contains: Bytes
  previousAdminRole_not_in: [Bytes!]
  role: Bytes
  role_contains: Bytes
  role_gt: Bytes
  role_gte: Bytes
  role_in: [Bytes!]
  role_lt: Bytes
  role_lte: Bytes
  role_not: Bytes
  role_not_contains: Bytes
  role_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum CrewsRoleAdminChanged_orderBy {
  blockNumber
  blockTimestamp
  id
  newAdminRole
  previousAdminRole
  role
  transactionHash
}

type CrewsRoleGranted {
  account: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  role: Bytes!
  sender: Bytes!
  transactionHash: Bytes!
}

input CrewsRoleGranted_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [CrewsRoleGranted_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [CrewsRoleGranted_filter]
  role: Bytes
  role_contains: Bytes
  role_gt: Bytes
  role_gte: Bytes
  role_in: [Bytes!]
  role_lt: Bytes
  role_lte: Bytes
  role_not: Bytes
  role_not_contains: Bytes
  role_not_in: [Bytes!]
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum CrewsRoleGranted_orderBy {
  account
  blockNumber
  blockTimestamp
  id
  role
  sender
  transactionHash
}

type CrewsRoleRevoked {
  account: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  role: Bytes!
  sender: Bytes!
  transactionHash: Bytes!
}

input CrewsRoleRevoked_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [CrewsRoleRevoked_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [CrewsRoleRevoked_filter]
  role: Bytes
  role_contains: Bytes
  role_gt: Bytes
  role_gte: Bytes
  role_in: [Bytes!]
  role_lt: Bytes
  role_lte: Bytes
  role_not: Bytes
  role_not_contains: Bytes
  role_not_in: [Bytes!]
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum CrewsRoleRevoked_orderBy {
  account
  blockNumber
  blockTimestamp
  id
  role
  sender
  transactionHash
}

type DeleteItemToInventory {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  itemIndex: BigInt!
  transactionHash: Bytes!
}

input DeleteItemToInventory_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [DeleteItemToInventory_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  itemIndex: BigInt
  itemIndex_gt: BigInt
  itemIndex_gte: BigInt
  itemIndex_in: [BigInt!]
  itemIndex_lt: BigInt
  itemIndex_lte: BigInt
  itemIndex_not: BigInt
  itemIndex_not_in: [BigInt!]
  or: [DeleteItemToInventory_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum DeleteItemToInventory_orderBy {
  blockNumber
  blockTimestamp
  crewId
  id
  itemIndex
  transactionHash
}

type DepositPouch {
  amount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  pouchId: BigInt!
  transactionHash: Bytes!
}

input DepositPouch_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  and: [DepositPouch_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [DepositPouch_filter]
  pouchId: BigInt
  pouchId_gt: BigInt
  pouchId_gte: BigInt
  pouchId_in: [BigInt!]
  pouchId_lt: BigInt
  pouchId_lte: BigInt
  pouchId_not: BigInt
  pouchId_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum DepositPouch_orderBy {
  amount
  blockNumber
  blockTimestamp
  crewId
  id
  pouchId
  transactionHash
}

type DurabilityChange {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  newDurability: BigInt!
  transactionHash: Bytes!
}

input DurabilityChange_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [DurabilityChange_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  newDurability: BigInt
  newDurability_gt: BigInt
  newDurability_gte: BigInt
  newDurability_in: [BigInt!]
  newDurability_lt: BigInt
  newDurability_lte: BigInt
  newDurability_not: BigInt
  newDurability_not_in: [BigInt!]
  or: [DurabilityChange_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum DurabilityChange_orderBy {
  blockNumber
  blockTimestamp
  crewId
  id
  newDurability
  transactionHash
}

type EquipItemToOoga {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  itemIndex: BigInt!
  oogaId: BigInt!
  transactionHash: Bytes!
}

input EquipItemToOoga_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [EquipItemToOoga_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  itemIndex: BigInt
  itemIndex_gt: BigInt
  itemIndex_gte: BigInt
  itemIndex_in: [BigInt!]
  itemIndex_lt: BigInt
  itemIndex_lte: BigInt
  itemIndex_not: BigInt
  itemIndex_not_in: [BigInt!]
  oogaId: BigInt
  oogaId_gt: BigInt
  oogaId_gte: BigInt
  oogaId_in: [BigInt!]
  oogaId_lt: BigInt
  oogaId_lte: BigInt
  oogaId_not: BigInt
  oogaId_not_in: [BigInt!]
  or: [EquipItemToOoga_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum EquipItemToOoga_orderBy {
  blockNumber
  blockTimestamp
  crewId
  id
  itemIndex
  oogaId
  transactionHash
}

type EquipSpecialItem {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  itemIndex: BigInt!
  oogaId: BigInt!
  transactionHash: Bytes!
}

input EquipSpecialItem_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [EquipSpecialItem_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  itemIndex: BigInt
  itemIndex_gt: BigInt
  itemIndex_gte: BigInt
  itemIndex_in: [BigInt!]
  itemIndex_lt: BigInt
  itemIndex_lte: BigInt
  itemIndex_not: BigInt
  itemIndex_not_in: [BigInt!]
  oogaId: BigInt
  oogaId_gt: BigInt
  oogaId_gte: BigInt
  oogaId_in: [BigInt!]
  oogaId_lt: BigInt
  oogaId_lte: BigInt
  oogaId_not: BigInt
  oogaId_not_in: [BigInt!]
  or: [EquipSpecialItem_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum EquipSpecialItem_orderBy {
  blockNumber
  blockTimestamp
  crewId
  id
  itemIndex
  oogaId
  transactionHash
}

type Initialized {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  transactionHash: Bytes!
  version: Int!
}

input Initialized_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Initialized_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [Initialized_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  version: Int
  version_gt: Int
  version_gte: Int
  version_in: [Int!]
  version_lt: Int
  version_lte: Int
  version_not: Int
  version_not_in: [Int!]
}

enum Initialized_orderBy {
  blockNumber
  blockTimestamp
  id
  transactionHash
  version
}

type InventoryItem {
  active: Boolean!
  attributes: Item
  charge: BigInt
  equipedToOoga: Ooga
  id: String!
  inCrew: Crew
  index: Int!
}

input InventoryItem_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  active: Boolean
  active_in: [Boolean!]
  active_not: Boolean
  active_not_in: [Boolean!]
  and: [InventoryItem_filter]
  attributes: String
  attributes_: Item_filter
  attributes_contains: String
  attributes_contains_nocase: String
  attributes_ends_with: String
  attributes_ends_with_nocase: String
  attributes_gt: String
  attributes_gte: String
  attributes_in: [String!]
  attributes_lt: String
  attributes_lte: String
  attributes_not: String
  attributes_not_contains: String
  attributes_not_contains_nocase: String
  attributes_not_ends_with: String
  attributes_not_ends_with_nocase: String
  attributes_not_in: [String!]
  attributes_not_starts_with: String
  attributes_not_starts_with_nocase: String
  attributes_starts_with: String
  attributes_starts_with_nocase: String
  charge: BigInt
  charge_gt: BigInt
  charge_gte: BigInt
  charge_in: [BigInt!]
  charge_lt: BigInt
  charge_lte: BigInt
  charge_not: BigInt
  charge_not_in: [BigInt!]
  equipedToOoga: String
  equipedToOoga_: Ooga_filter
  equipedToOoga_contains: String
  equipedToOoga_contains_nocase: String
  equipedToOoga_ends_with: String
  equipedToOoga_ends_with_nocase: String
  equipedToOoga_gt: String
  equipedToOoga_gte: String
  equipedToOoga_in: [String!]
  equipedToOoga_lt: String
  equipedToOoga_lte: String
  equipedToOoga_not: String
  equipedToOoga_not_contains: String
  equipedToOoga_not_contains_nocase: String
  equipedToOoga_not_ends_with: String
  equipedToOoga_not_ends_with_nocase: String
  equipedToOoga_not_in: [String!]
  equipedToOoga_not_starts_with: String
  equipedToOoga_not_starts_with_nocase: String
  equipedToOoga_starts_with: String
  equipedToOoga_starts_with_nocase: String
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  inCrew: String
  inCrew_: Crew_filter
  inCrew_contains: String
  inCrew_contains_nocase: String
  inCrew_ends_with: String
  inCrew_ends_with_nocase: String
  inCrew_gt: String
  inCrew_gte: String
  inCrew_in: [String!]
  inCrew_lt: String
  inCrew_lte: String
  inCrew_not: String
  inCrew_not_contains: String
  inCrew_not_contains_nocase: String
  inCrew_not_ends_with: String
  inCrew_not_ends_with_nocase: String
  inCrew_not_in: [String!]
  inCrew_not_starts_with: String
  inCrew_not_starts_with_nocase: String
  inCrew_starts_with: String
  inCrew_starts_with_nocase: String
  index: Int
  index_gt: Int
  index_gte: Int
  index_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_not: Int
  index_not_in: [Int!]
  or: [InventoryItem_filter]
}

enum InventoryItem_orderBy {
  active
  attributes
  charge
  equipedToOoga
  id
  inCrew
  index
}

type Item {
  abilities: [Int]!
  attack: BigInt!
  health: BigInt!
  id: String!
  itemType: Int!
  level: BigInt!
  season: BigInt!
  uri: String
}

input Item_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  abilities: [Int!]
  abilities_contains: [Int!]
  abilities_contains_nocase: [Int!]
  abilities_not: [Int!]
  abilities_not_contains: [Int!]
  abilities_not_contains_nocase: [Int!]
  and: [Item_filter]
  attack: BigInt
  attack_gt: BigInt
  attack_gte: BigInt
  attack_in: [BigInt!]
  attack_lt: BigInt
  attack_lte: BigInt
  attack_not: BigInt
  attack_not_in: [BigInt!]
  health: BigInt
  health_gt: BigInt
  health_gte: BigInt
  health_in: [BigInt!]
  health_lt: BigInt
  health_lte: BigInt
  health_not: BigInt
  health_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  itemType: Int
  itemType_gt: Int
  itemType_gte: Int
  itemType_in: [Int!]
  itemType_lt: Int
  itemType_lte: Int
  itemType_not: Int
  itemType_not_in: [Int!]
  level: BigInt
  level_gt: BigInt
  level_gte: BigInt
  level_in: [BigInt!]
  level_lt: BigInt
  level_lte: BigInt
  level_not: BigInt
  level_not_in: [BigInt!]
  or: [Item_filter]
  season: BigInt
  season_gt: BigInt
  season_gte: BigInt
  season_in: [BigInt!]
  season_lt: BigInt
  season_lte: BigInt
  season_not: BigInt
  season_not_in: [BigInt!]
  uri: String
  uri_contains: String
  uri_contains_nocase: String
  uri_ends_with: String
  uri_ends_with_nocase: String
  uri_gt: String
  uri_gte: String
  uri_in: [String!]
  uri_lt: String
  uri_lte: String
  uri_not: String
  uri_not_contains: String
  uri_not_contains_nocase: String
  uri_not_ends_with: String
  uri_not_ends_with_nocase: String
  uri_not_in: [String!]
  uri_not_starts_with: String
  uri_not_starts_with_nocase: String
  uri_starts_with: String
  uri_starts_with_nocase: String
}

enum Item_orderBy {
  abilities
  attack
  health
  id
  itemType
  level
  season
  uri
}

type LevelChange {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  newLevel: BigInt!
  transactionHash: Bytes!
}

input LevelChange_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [LevelChange_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  newLevel: BigInt
  newLevel_gt: BigInt
  newLevel_gte: BigInt
  newLevel_in: [BigInt!]
  newLevel_lt: BigInt
  newLevel_lte: BigInt
  newLevel_not: BigInt
  newLevel_not_in: [BigInt!]
  or: [LevelChange_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum LevelChange_orderBy {
  blockNumber
  blockTimestamp
  crewId
  id
  newLevel
  transactionHash
}

type MakeNewCrew {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  durability: BigInt!
  id: Bytes!
  mekaApeId: BigInt!
  rating: BigInt!
  transactionHash: Bytes!
  user: Bytes!
}

input MakeNewCrew_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [MakeNewCrew_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  durability: BigInt
  durability_gt: BigInt
  durability_gte: BigInt
  durability_in: [BigInt!]
  durability_lt: BigInt
  durability_lte: BigInt
  durability_not: BigInt
  durability_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  mekaApeId: BigInt
  mekaApeId_gt: BigInt
  mekaApeId_gte: BigInt
  mekaApeId_in: [BigInt!]
  mekaApeId_lt: BigInt
  mekaApeId_lte: BigInt
  mekaApeId_not: BigInt
  mekaApeId_not_in: [BigInt!]
  or: [MakeNewCrew_filter]
  rating: BigInt
  rating_gt: BigInt
  rating_gte: BigInt
  rating_in: [BigInt!]
  rating_lt: BigInt
  rating_lte: BigInt
  rating_not: BigInt
  rating_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  user: Bytes
  user_contains: Bytes
  user_gt: Bytes
  user_gte: Bytes
  user_in: [Bytes!]
  user_lt: Bytes
  user_lte: Bytes
  user_not: Bytes
  user_not_contains: Bytes
  user_not_in: [Bytes!]
}

enum MakeNewCrew_orderBy {
  blockNumber
  blockTimestamp
  crewId
  durability
  id
  mekaApeId
  rating
  transactionHash
  user
}

type Match {
  bucket: Bucket
  firstCrew: CrewInBucket
  id: String!
  secondCrew: CrewInBucket
  wonCrewId: String
}

input Match_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Match_filter]
  bucket: String
  bucket_: Bucket_filter
  bucket_contains: String
  bucket_contains_nocase: String
  bucket_ends_with: String
  bucket_ends_with_nocase: String
  bucket_gt: String
  bucket_gte: String
  bucket_in: [String!]
  bucket_lt: String
  bucket_lte: String
  bucket_not: String
  bucket_not_contains: String
  bucket_not_contains_nocase: String
  bucket_not_ends_with: String
  bucket_not_ends_with_nocase: String
  bucket_not_in: [String!]
  bucket_not_starts_with: String
  bucket_not_starts_with_nocase: String
  bucket_starts_with: String
  bucket_starts_with_nocase: String
  firstCrew: String
  firstCrew_: CrewInBucket_filter
  firstCrew_contains: String
  firstCrew_contains_nocase: String
  firstCrew_ends_with: String
  firstCrew_ends_with_nocase: String
  firstCrew_gt: String
  firstCrew_gte: String
  firstCrew_in: [String!]
  firstCrew_lt: String
  firstCrew_lte: String
  firstCrew_not: String
  firstCrew_not_contains: String
  firstCrew_not_contains_nocase: String
  firstCrew_not_ends_with: String
  firstCrew_not_ends_with_nocase: String
  firstCrew_not_in: [String!]
  firstCrew_not_starts_with: String
  firstCrew_not_starts_with_nocase: String
  firstCrew_starts_with: String
  firstCrew_starts_with_nocase: String
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [Match_filter]
  secondCrew: String
  secondCrew_: CrewInBucket_filter
  secondCrew_contains: String
  secondCrew_contains_nocase: String
  secondCrew_ends_with: String
  secondCrew_ends_with_nocase: String
  secondCrew_gt: String
  secondCrew_gte: String
  secondCrew_in: [String!]
  secondCrew_lt: String
  secondCrew_lte: String
  secondCrew_not: String
  secondCrew_not_contains: String
  secondCrew_not_contains_nocase: String
  secondCrew_not_ends_with: String
  secondCrew_not_ends_with_nocase: String
  secondCrew_not_in: [String!]
  secondCrew_not_starts_with: String
  secondCrew_not_starts_with_nocase: String
  secondCrew_starts_with: String
  secondCrew_starts_with_nocase: String
  wonCrewId: String
  wonCrewId_contains: String
  wonCrewId_contains_nocase: String
  wonCrewId_ends_with: String
  wonCrewId_ends_with_nocase: String
  wonCrewId_gt: String
  wonCrewId_gte: String
  wonCrewId_in: [String!]
  wonCrewId_lt: String
  wonCrewId_lte: String
  wonCrewId_not: String
  wonCrewId_not_contains: String
  wonCrewId_not_contains_nocase: String
  wonCrewId_not_ends_with: String
  wonCrewId_not_ends_with_nocase: String
  wonCrewId_not_in: [String!]
  wonCrewId_not_starts_with: String
  wonCrewId_not_starts_with_nocase: String
  wonCrewId_starts_with: String
  wonCrewId_starts_with_nocase: String
}

enum Match_orderBy {
  bucket
  firstCrew
  id
  secondCrew
  wonCrewId
}

type MatchmakingInitialized {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  transactionHash: Bytes!
  version: Int!
}

input MatchmakingInitialized_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [MatchmakingInitialized_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [MatchmakingInitialized_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  version: Int
  version_gt: Int
  version_gte: Int
  version_in: [Int!]
  version_lt: Int
  version_lte: Int
  version_not: Int
  version_not_in: [Int!]
}

enum MatchmakingInitialized_orderBy {
  blockNumber
  blockTimestamp
  id
  transactionHash
  version
}

type MatchmakingRoleAdminChanged {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  newAdminRole: Bytes!
  previousAdminRole: Bytes!
  role: Bytes!
  transactionHash: Bytes!
}

input MatchmakingRoleAdminChanged_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [MatchmakingRoleAdminChanged_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  newAdminRole: Bytes
  newAdminRole_contains: Bytes
  newAdminRole_gt: Bytes
  newAdminRole_gte: Bytes
  newAdminRole_in: [Bytes!]
  newAdminRole_lt: Bytes
  newAdminRole_lte: Bytes
  newAdminRole_not: Bytes
  newAdminRole_not_contains: Bytes
  newAdminRole_not_in: [Bytes!]
  or: [MatchmakingRoleAdminChanged_filter]
  previousAdminRole: Bytes
  previousAdminRole_contains: Bytes
  previousAdminRole_gt: Bytes
  previousAdminRole_gte: Bytes
  previousAdminRole_in: [Bytes!]
  previousAdminRole_lt: Bytes
  previousAdminRole_lte: Bytes
  previousAdminRole_not: Bytes
  previousAdminRole_not_contains: Bytes
  previousAdminRole_not_in: [Bytes!]
  role: Bytes
  role_contains: Bytes
  role_gt: Bytes
  role_gte: Bytes
  role_in: [Bytes!]
  role_lt: Bytes
  role_lte: Bytes
  role_not: Bytes
  role_not_contains: Bytes
  role_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum MatchmakingRoleAdminChanged_orderBy {
  blockNumber
  blockTimestamp
  id
  newAdminRole
  previousAdminRole
  role
  transactionHash
}

type MatchmakingRoleGranted {
  account: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  role: Bytes!
  sender: Bytes!
  transactionHash: Bytes!
}

input MatchmakingRoleGranted_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [MatchmakingRoleGranted_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [MatchmakingRoleGranted_filter]
  role: Bytes
  role_contains: Bytes
  role_gt: Bytes
  role_gte: Bytes
  role_in: [Bytes!]
  role_lt: Bytes
  role_lte: Bytes
  role_not: Bytes
  role_not_contains: Bytes
  role_not_in: [Bytes!]
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum MatchmakingRoleGranted_orderBy {
  account
  blockNumber
  blockTimestamp
  id
  role
  sender
  transactionHash
}

type MatchmakingRoleRevoked {
  account: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  role: Bytes!
  sender: Bytes!
  transactionHash: Bytes!
}

input MatchmakingRoleRevoked_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [MatchmakingRoleRevoked_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [MatchmakingRoleRevoked_filter]
  role: Bytes
  role_contains: Bytes
  role_gt: Bytes
  role_gte: Bytes
  role_in: [Bytes!]
  role_lt: Bytes
  role_lte: Bytes
  role_not: Bytes
  role_not_contains: Bytes
  role_not_in: [Bytes!]
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum MatchmakingRoleRevoked_orderBy {
  account
  blockNumber
  blockTimestamp
  id
  role
  sender
  transactionHash
}

type MekawarsItemsApprovalForAll {
  account: Bytes!
  approved: Boolean!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  operator: Bytes!
  transactionHash: Bytes!
}

input MekawarsItemsApprovalForAll_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [MekawarsItemsApprovalForAll_filter]
  approved: Boolean
  approved_in: [Boolean!]
  approved_not: Boolean
  approved_not_in: [Boolean!]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  operator: Bytes
  operator_contains: Bytes
  operator_gt: Bytes
  operator_gte: Bytes
  operator_in: [Bytes!]
  operator_lt: Bytes
  operator_lte: Bytes
  operator_not: Bytes
  operator_not_contains: Bytes
  operator_not_in: [Bytes!]
  or: [MekawarsItemsApprovalForAll_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum MekawarsItemsApprovalForAll_orderBy {
  account
  approved
  blockNumber
  blockTimestamp
  id
  operator
  transactionHash
}

type MekawarsItemsInitialized {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  transactionHash: Bytes!
  version: Int!
}

input MekawarsItemsInitialized_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [MekawarsItemsInitialized_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [MekawarsItemsInitialized_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  version: Int
  version_gt: Int
  version_gte: Int
  version_in: [Int!]
  version_lt: Int
  version_lte: Int
  version_not: Int
  version_not_in: [Int!]
}

enum MekawarsItemsInitialized_orderBy {
  blockNumber
  blockTimestamp
  id
  transactionHash
  version
}

type MekawarsItemsRoleAdminChanged {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  newAdminRole: Bytes!
  previousAdminRole: Bytes!
  role: Bytes!
  transactionHash: Bytes!
}

input MekawarsItemsRoleAdminChanged_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [MekawarsItemsRoleAdminChanged_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  newAdminRole: Bytes
  newAdminRole_contains: Bytes
  newAdminRole_gt: Bytes
  newAdminRole_gte: Bytes
  newAdminRole_in: [Bytes!]
  newAdminRole_lt: Bytes
  newAdminRole_lte: Bytes
  newAdminRole_not: Bytes
  newAdminRole_not_contains: Bytes
  newAdminRole_not_in: [Bytes!]
  or: [MekawarsItemsRoleAdminChanged_filter]
  previousAdminRole: Bytes
  previousAdminRole_contains: Bytes
  previousAdminRole_gt: Bytes
  previousAdminRole_gte: Bytes
  previousAdminRole_in: [Bytes!]
  previousAdminRole_lt: Bytes
  previousAdminRole_lte: Bytes
  previousAdminRole_not: Bytes
  previousAdminRole_not_contains: Bytes
  previousAdminRole_not_in: [Bytes!]
  role: Bytes
  role_contains: Bytes
  role_gt: Bytes
  role_gte: Bytes
  role_in: [Bytes!]
  role_lt: Bytes
  role_lte: Bytes
  role_not: Bytes
  role_not_contains: Bytes
  role_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum MekawarsItemsRoleAdminChanged_orderBy {
  blockNumber
  blockTimestamp
  id
  newAdminRole
  previousAdminRole
  role
  transactionHash
}

type MekawarsItemsRoleGranted {
  account: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  role: Bytes!
  sender: Bytes!
  transactionHash: Bytes!
}

input MekawarsItemsRoleGranted_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [MekawarsItemsRoleGranted_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [MekawarsItemsRoleGranted_filter]
  role: Bytes
  role_contains: Bytes
  role_gt: Bytes
  role_gte: Bytes
  role_in: [Bytes!]
  role_lt: Bytes
  role_lte: Bytes
  role_not: Bytes
  role_not_contains: Bytes
  role_not_in: [Bytes!]
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum MekawarsItemsRoleGranted_orderBy {
  account
  blockNumber
  blockTimestamp
  id
  role
  sender
  transactionHash
}

type MekawarsItemsRoleRevoked {
  account: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  role: Bytes!
  sender: Bytes!
  transactionHash: Bytes!
}

input MekawarsItemsRoleRevoked_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [MekawarsItemsRoleRevoked_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [MekawarsItemsRoleRevoked_filter]
  role: Bytes
  role_contains: Bytes
  role_gt: Bytes
  role_gte: Bytes
  role_in: [Bytes!]
  role_lt: Bytes
  role_lte: Bytes
  role_not: Bytes
  role_not_contains: Bytes
  role_not_in: [Bytes!]
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum MekawarsItemsRoleRevoked_orderBy {
  account
  blockNumber
  blockTimestamp
  id
  role
  sender
  transactionHash
}

type MysteryBoxOpened {
  NTWon: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  itemsWon: [BigInt!]!
  level: BigInt!
  transactionHash: Bytes!
}

input MysteryBoxOpened_filter {
  NTWon: BigInt
  NTWon_gt: BigInt
  NTWon_gte: BigInt
  NTWon_in: [BigInt!]
  NTWon_lt: BigInt
  NTWon_lte: BigInt
  NTWon_not: BigInt
  NTWon_not_in: [BigInt!]

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [MysteryBoxOpened_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  itemsWon: [BigInt!]
  itemsWon_contains: [BigInt!]
  itemsWon_contains_nocase: [BigInt!]
  itemsWon_not: [BigInt!]
  itemsWon_not_contains: [BigInt!]
  itemsWon_not_contains_nocase: [BigInt!]
  level: BigInt
  level_gt: BigInt
  level_gte: BigInt
  level_in: [BigInt!]
  level_lt: BigInt
  level_lte: BigInt
  level_not: BigInt
  level_not_in: [BigInt!]
  or: [MysteryBoxOpened_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum MysteryBoxOpened_orderBy {
  NTWon
  blockNumber
  blockTimestamp
  crewId
  id
  itemsWon
  level
  transactionHash
}

type NTChange {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  change: BigInt!
  crewId: BigInt!
  id: Bytes!
  newNTamount: BigInt!
  transactionHash: Bytes!
}

input NTChange_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [NTChange_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  change: BigInt
  change_gt: BigInt
  change_gte: BigInt
  change_in: [BigInt!]
  change_lt: BigInt
  change_lte: BigInt
  change_not: BigInt
  change_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  newNTamount: BigInt
  newNTamount_gt: BigInt
  newNTamount_gte: BigInt
  newNTamount_in: [BigInt!]
  newNTamount_lt: BigInt
  newNTamount_lte: BigInt
  newNTamount_not: BigInt
  newNTamount_not_in: [BigInt!]
  or: [NTChange_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum NTChange_orderBy {
  blockNumber
  blockTimestamp
  change
  crewId
  id
  newNTamount
  transactionHash
}

type NTPouch {
  active: Boolean!
  amount: BigInt!
  id: String!
  uri: String
}

type NTPouchApprovalForAll {
  account: Bytes!
  approved: Boolean!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  operator: Bytes!
  transactionHash: Bytes!
}

input NTPouchApprovalForAll_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [NTPouchApprovalForAll_filter]
  approved: Boolean
  approved_in: [Boolean!]
  approved_not: Boolean
  approved_not_in: [Boolean!]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  operator: Bytes
  operator_contains: Bytes
  operator_gt: Bytes
  operator_gte: Bytes
  operator_in: [Bytes!]
  operator_lt: Bytes
  operator_lte: Bytes
  operator_not: Bytes
  operator_not_contains: Bytes
  operator_not_in: [Bytes!]
  or: [NTPouchApprovalForAll_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum NTPouchApprovalForAll_orderBy {
  account
  approved
  blockNumber
  blockTimestamp
  id
  operator
  transactionHash
}

type NTPouchInitialized {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  transactionHash: Bytes!
  version: Int!
}

input NTPouchInitialized_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [NTPouchInitialized_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [NTPouchInitialized_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  version: Int
  version_gt: Int
  version_gte: Int
  version_in: [Int!]
  version_lt: Int
  version_lte: Int
  version_not: Int
  version_not_in: [Int!]
}

enum NTPouchInitialized_orderBy {
  blockNumber
  blockTimestamp
  id
  transactionHash
  version
}

type NTPouchRoleAdminChanged {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  newAdminRole: Bytes!
  previousAdminRole: Bytes!
  role: Bytes!
  transactionHash: Bytes!
}

input NTPouchRoleAdminChanged_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [NTPouchRoleAdminChanged_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  newAdminRole: Bytes
  newAdminRole_contains: Bytes
  newAdminRole_gt: Bytes
  newAdminRole_gte: Bytes
  newAdminRole_in: [Bytes!]
  newAdminRole_lt: Bytes
  newAdminRole_lte: Bytes
  newAdminRole_not: Bytes
  newAdminRole_not_contains: Bytes
  newAdminRole_not_in: [Bytes!]
  or: [NTPouchRoleAdminChanged_filter]
  previousAdminRole: Bytes
  previousAdminRole_contains: Bytes
  previousAdminRole_gt: Bytes
  previousAdminRole_gte: Bytes
  previousAdminRole_in: [Bytes!]
  previousAdminRole_lt: Bytes
  previousAdminRole_lte: Bytes
  previousAdminRole_not: Bytes
  previousAdminRole_not_contains: Bytes
  previousAdminRole_not_in: [Bytes!]
  role: Bytes
  role_contains: Bytes
  role_gt: Bytes
  role_gte: Bytes
  role_in: [Bytes!]
  role_lt: Bytes
  role_lte: Bytes
  role_not: Bytes
  role_not_contains: Bytes
  role_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum NTPouchRoleAdminChanged_orderBy {
  blockNumber
  blockTimestamp
  id
  newAdminRole
  previousAdminRole
  role
  transactionHash
}

type NTPouchRoleGranted {
  account: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  role: Bytes!
  sender: Bytes!
  transactionHash: Bytes!
}

input NTPouchRoleGranted_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [NTPouchRoleGranted_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [NTPouchRoleGranted_filter]
  role: Bytes
  role_contains: Bytes
  role_gt: Bytes
  role_gte: Bytes
  role_in: [Bytes!]
  role_lt: Bytes
  role_lte: Bytes
  role_not: Bytes
  role_not_contains: Bytes
  role_not_in: [Bytes!]
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum NTPouchRoleGranted_orderBy {
  account
  blockNumber
  blockTimestamp
  id
  role
  sender
  transactionHash
}

type NTPouchRoleRevoked {
  account: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  role: Bytes!
  sender: Bytes!
  transactionHash: Bytes!
}

input NTPouchRoleRevoked_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [NTPouchRoleRevoked_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [NTPouchRoleRevoked_filter]
  role: Bytes
  role_contains: Bytes
  role_gt: Bytes
  role_gte: Bytes
  role_in: [Bytes!]
  role_lt: Bytes
  role_lte: Bytes
  role_not: Bytes
  role_not_contains: Bytes
  role_not_in: [Bytes!]
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum NTPouchRoleRevoked_orderBy {
  account
  blockNumber
  blockTimestamp
  id
  role
  sender
  transactionHash
}

type NTPouchTransferBatch {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  from: Bytes!
  id: Bytes!
  ids: [BigInt!]!
  operator: Bytes!
  to: Bytes!
  transactionHash: Bytes!
  values: [BigInt!]!
}

input NTPouchTransferBatch_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [NTPouchTransferBatch_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  from: Bytes
  from_contains: Bytes
  from_gt: Bytes
  from_gte: Bytes
  from_in: [Bytes!]
  from_lt: Bytes
  from_lte: Bytes
  from_not: Bytes
  from_not_contains: Bytes
  from_not_in: [Bytes!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  ids: [BigInt!]
  ids_contains: [BigInt!]
  ids_contains_nocase: [BigInt!]
  ids_not: [BigInt!]
  ids_not_contains: [BigInt!]
  ids_not_contains_nocase: [BigInt!]
  operator: Bytes
  operator_contains: Bytes
  operator_gt: Bytes
  operator_gte: Bytes
  operator_in: [Bytes!]
  operator_lt: Bytes
  operator_lte: Bytes
  operator_not: Bytes
  operator_not_contains: Bytes
  operator_not_in: [Bytes!]
  or: [NTPouchTransferBatch_filter]
  to: Bytes
  to_contains: Bytes
  to_gt: Bytes
  to_gte: Bytes
  to_in: [Bytes!]
  to_lt: Bytes
  to_lte: Bytes
  to_not: Bytes
  to_not_contains: Bytes
  to_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  values: [BigInt!]
  values_contains: [BigInt!]
  values_contains_nocase: [BigInt!]
  values_not: [BigInt!]
  values_not_contains: [BigInt!]
  values_not_contains_nocase: [BigInt!]
}

enum NTPouchTransferBatch_orderBy {
  blockNumber
  blockTimestamp
  from
  id
  ids
  operator
  to
  transactionHash
  values
}

type NTPouchTransferSingle {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  from: Bytes!
  id: Bytes!
  operator: Bytes!
  to: Bytes!
  tokenId: BigInt!
  transactionHash: Bytes!
  value: BigInt!
}

input NTPouchTransferSingle_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [NTPouchTransferSingle_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  from: Bytes
  from_contains: Bytes
  from_gt: Bytes
  from_gte: Bytes
  from_in: [Bytes!]
  from_lt: Bytes
  from_lte: Bytes
  from_not: Bytes
  from_not_contains: Bytes
  from_not_in: [Bytes!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  operator: Bytes
  operator_contains: Bytes
  operator_gt: Bytes
  operator_gte: Bytes
  operator_in: [Bytes!]
  operator_lt: Bytes
  operator_lte: Bytes
  operator_not: Bytes
  operator_not_contains: Bytes
  operator_not_in: [Bytes!]
  or: [NTPouchTransferSingle_filter]
  to: Bytes
  to_contains: Bytes
  to_gt: Bytes
  to_gte: Bytes
  to_in: [Bytes!]
  to_lt: Bytes
  to_lte: Bytes
  to_not: Bytes
  to_not_contains: Bytes
  to_not_in: [Bytes!]
  tokenId: BigInt
  tokenId_gt: BigInt
  tokenId_gte: BigInt
  tokenId_in: [BigInt!]
  tokenId_lt: BigInt
  tokenId_lte: BigInt
  tokenId_not: BigInt
  tokenId_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum NTPouchTransferSingle_orderBy {
  blockNumber
  blockTimestamp
  from
  id
  operator
  to
  tokenId
  transactionHash
  value
}

type NTPouchURI {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  tokenId: BigInt!
  transactionHash: Bytes!
  value: String!
}

input NTPouchURI_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [NTPouchURI_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [NTPouchURI_filter]
  tokenId: BigInt
  tokenId_gt: BigInt
  tokenId_gte: BigInt
  tokenId_in: [BigInt!]
  tokenId_lt: BigInt
  tokenId_lte: BigInt
  tokenId_not: BigInt
  tokenId_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: String
  value_contains: String
  value_contains_nocase: String
  value_ends_with: String
  value_ends_with_nocase: String
  value_gt: String
  value_gte: String
  value_in: [String!]
  value_lt: String
  value_lte: String
  value_not: String
  value_not_contains: String
  value_not_contains_nocase: String
  value_not_ends_with: String
  value_not_ends_with_nocase: String
  value_not_in: [String!]
  value_not_starts_with: String
  value_not_starts_with_nocase: String
  value_starts_with: String
  value_starts_with_nocase: String
}

enum NTPouchURI_orderBy {
  blockNumber
  blockTimestamp
  id
  tokenId
  transactionHash
  value
}

input NTPouch_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  active: Boolean
  active_in: [Boolean!]
  active_not: Boolean
  active_not_in: [Boolean!]
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  and: [NTPouch_filter]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [NTPouch_filter]
  uri: String
  uri_contains: String
  uri_contains_nocase: String
  uri_ends_with: String
  uri_ends_with_nocase: String
  uri_gt: String
  uri_gte: String
  uri_in: [String!]
  uri_lt: String
  uri_lte: String
  uri_not: String
  uri_not_contains: String
  uri_not_contains_nocase: String
  uri_not_ends_with: String
  uri_not_ends_with_nocase: String
  uri_not_in: [String!]
  uri_not_starts_with: String
  uri_not_starts_with_nocase: String
  uri_starts_with: String
  uri_starts_with_nocase: String
}

enum NTPouch_orderBy {
  active
  amount
  id
  uri
}

type NewBucket {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  bucketIndex: BigInt!
  createdAt: BigInt!
  id: Bytes!
  transactionHash: Bytes!
}

input NewBucket_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [NewBucket_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  bucketIndex: BigInt
  bucketIndex_gt: BigInt
  bucketIndex_gte: BigInt
  bucketIndex_in: [BigInt!]
  bucketIndex_lt: BigInt
  bucketIndex_lte: BigInt
  bucketIndex_not: BigInt
  bucketIndex_not_in: [BigInt!]
  createdAt: BigInt
  createdAt_gt: BigInt
  createdAt_gte: BigInt
  createdAt_in: [BigInt!]
  createdAt_lt: BigInt
  createdAt_lte: BigInt
  createdAt_not: BigInt
  createdAt_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [NewBucket_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum NewBucket_orderBy {
  blockNumber
  blockTimestamp
  bucketIndex
  createdAt
  id
  transactionHash
}

type NewFirstTeam {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  newFirstTeam: [BigInt!]!
  transactionHash: Bytes!
}

input NewFirstTeam_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [NewFirstTeam_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  newFirstTeam: [BigInt!]
  newFirstTeam_contains: [BigInt!]
  newFirstTeam_contains_nocase: [BigInt!]
  newFirstTeam_not: [BigInt!]
  newFirstTeam_not_contains: [BigInt!]
  newFirstTeam_not_contains_nocase: [BigInt!]
  or: [NewFirstTeam_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum NewFirstTeam_orderBy {
  blockNumber
  blockTimestamp
  crewId
  id
  newFirstTeam
  transactionHash
}

type Ooga {
  attack: BigInt
  health: BigInt
  id: String!
  inCrew: Crew
  level: Int
  oogaType: Int
  orderIndexInFirstTeam: Int
  owner: User
}

input Ooga_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Ooga_filter]
  attack: BigInt
  attack_gt: BigInt
  attack_gte: BigInt
  attack_in: [BigInt!]
  attack_lt: BigInt
  attack_lte: BigInt
  attack_not: BigInt
  attack_not_in: [BigInt!]
  health: BigInt
  health_gt: BigInt
  health_gte: BigInt
  health_in: [BigInt!]
  health_lt: BigInt
  health_lte: BigInt
  health_not: BigInt
  health_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  inCrew: String
  inCrew_: Crew_filter
  inCrew_contains: String
  inCrew_contains_nocase: String
  inCrew_ends_with: String
  inCrew_ends_with_nocase: String
  inCrew_gt: String
  inCrew_gte: String
  inCrew_in: [String!]
  inCrew_lt: String
  inCrew_lte: String
  inCrew_not: String
  inCrew_not_contains: String
  inCrew_not_contains_nocase: String
  inCrew_not_ends_with: String
  inCrew_not_ends_with_nocase: String
  inCrew_not_in: [String!]
  inCrew_not_starts_with: String
  inCrew_not_starts_with_nocase: String
  inCrew_starts_with: String
  inCrew_starts_with_nocase: String
  level: Int
  level_gt: Int
  level_gte: Int
  level_in: [Int!]
  level_lt: Int
  level_lte: Int
  level_not: Int
  level_not_in: [Int!]
  oogaType: Int
  oogaType_gt: Int
  oogaType_gte: Int
  oogaType_in: [Int!]
  oogaType_lt: Int
  oogaType_lte: Int
  oogaType_not: Int
  oogaType_not_in: [Int!]
  or: [Ooga_filter]
  orderIndexInFirstTeam: Int
  orderIndexInFirstTeam_gt: Int
  orderIndexInFirstTeam_gte: Int
  orderIndexInFirstTeam_in: [Int!]
  orderIndexInFirstTeam_lt: Int
  orderIndexInFirstTeam_lte: Int
  orderIndexInFirstTeam_not: Int
  orderIndexInFirstTeam_not_in: [Int!]
  owner: String
  owner_: User_filter
  owner_contains: String
  owner_contains_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_gt: String
  owner_gte: String
  owner_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_not: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_not_in: [String!]
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
}

enum Ooga_orderBy {
  attack
  health
  id
  inCrew
  level
  oogaType
  orderIndexInFirstTeam
  owner
}

type OpenBox {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  newSlotState: Int!
  slotIndex: BigInt!
  transactionHash: Bytes!
}

input OpenBox_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [OpenBox_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  newSlotState: Int
  newSlotState_gt: Int
  newSlotState_gte: Int
  newSlotState_in: [Int!]
  newSlotState_lt: Int
  newSlotState_lte: Int
  newSlotState_not: Int
  newSlotState_not_in: [Int!]
  or: [OpenBox_filter]
  slotIndex: BigInt
  slotIndex_gt: BigInt
  slotIndex_gte: BigInt
  slotIndex_in: [BigInt!]
  slotIndex_lt: BigInt
  slotIndex_lte: BigInt
  slotIndex_not: BigInt
  slotIndex_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum OpenBox_orderBy {
  blockNumber
  blockTimestamp
  crewId
  id
  newSlotState
  slotIndex
  transactionHash
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
  asc
  desc
}

type Query {
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
  addCrewToBucket(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AddCrewToBucket
  addCrewToBuckets(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AddCrewToBucket_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AddCrewToBucket_filter
  ): [AddCrewToBucket!]!
  addItemToInventories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AddItemToInventory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AddItemToInventory_filter
  ): [AddItemToInventory!]!
  addItemToInventory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AddItemToInventory
  addRoboToCrew(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AddRoboToCrew
  addRoboToCrews(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AddRoboToCrew_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AddRoboToCrew_filter
  ): [AddRoboToCrew!]!
  approval(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Approval
  approvalForAll(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ApprovalForAll
  approvalForAlls(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ApprovalForAll_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ApprovalForAll_filter
  ): [ApprovalForAll!]!
  approvals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Approval_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Approval_filter
  ): [Approval!]!
  boxInitialized(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BoxInitialized
  boxInitializeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BoxInitialized_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BoxInitialized_filter
  ): [BoxInitialized!]!
  boxOpened(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BoxOpened
  boxOpeneds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BoxOpened_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BoxOpened_filter
  ): [BoxOpened!]!
  boxRoleAdminChanged(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BoxRoleAdminChanged
  boxRoleAdminChangeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BoxRoleAdminChanged_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BoxRoleAdminChanged_filter
  ): [BoxRoleAdminChanged!]!
  boxRoleGranted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BoxRoleGranted
  boxRoleGranteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BoxRoleGranted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BoxRoleGranted_filter
  ): [BoxRoleGranted!]!
  boxRoleRevoked(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BoxRoleRevoked
  boxRoleRevokeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BoxRoleRevoked_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BoxRoleRevoked_filter
  ): [BoxRoleRevoked!]!
  boxSlot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BoxSlot
  boxSlots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BoxSlot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BoxSlot_filter
  ): [BoxSlot!]!
  boxUpgraded(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BoxUpgraded
  boxUpgradeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BoxUpgraded_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BoxUpgraded_filter
  ): [BoxUpgraded!]!
  bucket(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Bucket
  buckets(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Bucket_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Bucket_filter
  ): [Bucket!]!
  buyMysteryBox(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BuyMysteryBox
  buyMysteryBoxes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BuyMysteryBox_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BuyMysteryBox_filter
  ): [BuyMysteryBox!]!
  changeBucketState(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ChangeBucketState
  changeBucketStates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ChangeBucketState_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ChangeBucketState_filter
  ): [ChangeBucketState!]!
  contractParameter(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ContractParameter
  contractParameters(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ContractParameter_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ContractParameter_filter
  ): [ContractParameter!]!
  crew(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Crew
  crewInBucket(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CrewInBucket
  crewInBuckets(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CrewInBucket_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CrewInBucket_filter
  ): [CrewInBucket!]!
  crews(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Crew_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Crew_filter
  ): [Crew!]!
  crewsInitialized(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CrewsInitialized
  crewsInitializeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CrewsInitialized_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CrewsInitialized_filter
  ): [CrewsInitialized!]!
  crewsRoleAdminChanged(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CrewsRoleAdminChanged
  crewsRoleAdminChangeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CrewsRoleAdminChanged_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CrewsRoleAdminChanged_filter
  ): [CrewsRoleAdminChanged!]!
  crewsRoleGranted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CrewsRoleGranted
  crewsRoleGranteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CrewsRoleGranted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CrewsRoleGranted_filter
  ): [CrewsRoleGranted!]!
  crewsRoleRevoked(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CrewsRoleRevoked
  crewsRoleRevokeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CrewsRoleRevoked_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CrewsRoleRevoked_filter
  ): [CrewsRoleRevoked!]!
  deleteItemToInventories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DeleteItemToInventory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DeleteItemToInventory_filter
  ): [DeleteItemToInventory!]!
  deleteItemToInventory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DeleteItemToInventory
  depositPouch(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DepositPouch
  depositPouches(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DepositPouch_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DepositPouch_filter
  ): [DepositPouch!]!
  durabilityChange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DurabilityChange
  durabilityChanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DurabilityChange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DurabilityChange_filter
  ): [DurabilityChange!]!
  equipItemToOoga(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): EquipItemToOoga
  equipItemToOogas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: EquipItemToOoga_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: EquipItemToOoga_filter
  ): [EquipItemToOoga!]!
  equipSpecialItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): EquipSpecialItem
  equipSpecialItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: EquipSpecialItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: EquipSpecialItem_filter
  ): [EquipSpecialItem!]!
  initialized(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Initialized
  initializeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Initialized_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Initialized_filter
  ): [Initialized!]!
  inventoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): InventoryItem
  inventoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: InventoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: InventoryItem_filter
  ): [InventoryItem!]!
  item(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Item
  items(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Item_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Item_filter
  ): [Item!]!
  levelChange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LevelChange
  levelChanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LevelChange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LevelChange_filter
  ): [LevelChange!]!
  makeNewCrew(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MakeNewCrew
  makeNewCrews(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MakeNewCrew_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MakeNewCrew_filter
  ): [MakeNewCrew!]!
  match(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Match
  matches(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Match_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Match_filter
  ): [Match!]!
  matchmakingInitialized(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MatchmakingInitialized
  matchmakingInitializeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MatchmakingInitialized_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MatchmakingInitialized_filter
  ): [MatchmakingInitialized!]!
  matchmakingRoleAdminChanged(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MatchmakingRoleAdminChanged
  matchmakingRoleAdminChangeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MatchmakingRoleAdminChanged_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MatchmakingRoleAdminChanged_filter
  ): [MatchmakingRoleAdminChanged!]!
  matchmakingRoleGranted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MatchmakingRoleGranted
  matchmakingRoleGranteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MatchmakingRoleGranted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MatchmakingRoleGranted_filter
  ): [MatchmakingRoleGranted!]!
  matchmakingRoleRevoked(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MatchmakingRoleRevoked
  matchmakingRoleRevokeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MatchmakingRoleRevoked_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MatchmakingRoleRevoked_filter
  ): [MatchmakingRoleRevoked!]!
  mekawarsItemsApprovalForAll(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MekawarsItemsApprovalForAll
  mekawarsItemsApprovalForAlls(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MekawarsItemsApprovalForAll_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MekawarsItemsApprovalForAll_filter
  ): [MekawarsItemsApprovalForAll!]!
  mekawarsItemsInitialized(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MekawarsItemsInitialized
  mekawarsItemsInitializeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MekawarsItemsInitialized_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MekawarsItemsInitialized_filter
  ): [MekawarsItemsInitialized!]!
  mekawarsItemsRoleAdminChanged(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MekawarsItemsRoleAdminChanged
  mekawarsItemsRoleAdminChangeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MekawarsItemsRoleAdminChanged_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MekawarsItemsRoleAdminChanged_filter
  ): [MekawarsItemsRoleAdminChanged!]!
  mekawarsItemsRoleGranted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MekawarsItemsRoleGranted
  mekawarsItemsRoleGranteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MekawarsItemsRoleGranted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MekawarsItemsRoleGranted_filter
  ): [MekawarsItemsRoleGranted!]!
  mekawarsItemsRoleRevoked(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MekawarsItemsRoleRevoked
  mekawarsItemsRoleRevokeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MekawarsItemsRoleRevoked_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MekawarsItemsRoleRevoked_filter
  ): [MekawarsItemsRoleRevoked!]!
  mysteryBoxOpened(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MysteryBoxOpened
  mysteryBoxOpeneds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MysteryBoxOpened_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MysteryBoxOpened_filter
  ): [MysteryBoxOpened!]!
  newBucket(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewBucket
  newBuckets(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NewBucket_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NewBucket_filter
  ): [NewBucket!]!
  newFirstTeam(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewFirstTeam
  newFirstTeams(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NewFirstTeam_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NewFirstTeam_filter
  ): [NewFirstTeam!]!
  ntchange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTChange
  ntchanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTChange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTChange_filter
  ): [NTChange!]!
  ntpouch(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTPouch
  ntpouchApprovalForAll(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTPouchApprovalForAll
  ntpouchApprovalForAlls(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTPouchApprovalForAll_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTPouchApprovalForAll_filter
  ): [NTPouchApprovalForAll!]!
  ntpouchInitialized(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTPouchInitialized
  ntpouchInitializeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTPouchInitialized_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTPouchInitialized_filter
  ): [NTPouchInitialized!]!
  ntpouchRoleAdminChanged(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTPouchRoleAdminChanged
  ntpouchRoleAdminChangeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTPouchRoleAdminChanged_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTPouchRoleAdminChanged_filter
  ): [NTPouchRoleAdminChanged!]!
  ntpouchRoleGranted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTPouchRoleGranted
  ntpouchRoleGranteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTPouchRoleGranted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTPouchRoleGranted_filter
  ): [NTPouchRoleGranted!]!
  ntpouchRoleRevoked(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTPouchRoleRevoked
  ntpouchRoleRevokeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTPouchRoleRevoked_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTPouchRoleRevoked_filter
  ): [NTPouchRoleRevoked!]!
  ntpouchTransferBatch(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTPouchTransferBatch
  ntpouchTransferBatches(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTPouchTransferBatch_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTPouchTransferBatch_filter
  ): [NTPouchTransferBatch!]!
  ntpouchTransferSingle(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTPouchTransferSingle
  ntpouchTransferSingles(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTPouchTransferSingle_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTPouchTransferSingle_filter
  ): [NTPouchTransferSingle!]!
  ntpouchURI(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTPouchURI
  ntpouchURIs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTPouchURI_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTPouchURI_filter
  ): [NTPouchURI!]!
  ntpouches(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTPouch_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTPouch_filter
  ): [NTPouch!]!
  ooga(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Ooga
  oogas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Ooga_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Ooga_filter
  ): [Ooga!]!
  openBox(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OpenBox
  openBoxes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OpenBox_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OpenBox_filter
  ): [OpenBox!]!
  ratingChange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RatingChange
  ratingChanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RatingChange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RatingChange_filter
  ): [RatingChange!]!
  removeCrew(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RemoveCrew
  removeCrewFromBucket(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RemoveCrewFromBucket
  removeCrewFromBuckets(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RemoveCrewFromBucket_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RemoveCrewFromBucket_filter
  ): [RemoveCrewFromBucket!]!
  removeCrews(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RemoveCrew_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RemoveCrew_filter
  ): [RemoveCrew!]!
  removeRoboFromCrew(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RemoveRoboFromCrew
  removeRoboFromCrews(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RemoveRoboFromCrew_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RemoveRoboFromCrew_filter
  ): [RemoveRoboFromCrew!]!
  resolveMatch(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ResolveMatch
  resolveMatches(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ResolveMatch_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ResolveMatch_filter
  ): [ResolveMatch!]!
  roleAdminChanged(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RoleAdminChanged
  roleAdminChangeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RoleAdminChanged_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RoleAdminChanged_filter
  ): [RoleAdminChanged!]!
  roleGranted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RoleGranted
  roleGranteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RoleGranted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RoleGranted_filter
  ): [RoleGranted!]!
  roleRevoked(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RoleRevoked
  roleRevokeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RoleRevoked_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RoleRevoked_filter
  ): [RoleRevoked!]!
  setBucketRandomSeed(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetBucketRandomSeed
  setBucketRandomSeeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SetBucketRandomSeed_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SetBucketRandomSeed_filter
  ): [SetBucketRandomSeed!]!
  setItemAttribute(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetItemAttribute
  setItemAttributes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SetItemAttribute_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SetItemAttribute_filter
  ): [SetItemAttribute!]!
  setOogaAttribute(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetOogaAttribute
  setOogaAttributes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SetOogaAttribute_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SetOogaAttribute_filter
  ): [SetOogaAttribute!]!
  setPouchAttribute(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetPouchAttribute
  setPouchAttributes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SetPouchAttribute_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SetPouchAttribute_filter
  ): [SetPouchAttribute!]!
  stakeBabyOoga(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeBabyOoga
  stakeBabyOogas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StakeBabyOoga_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StakeBabyOoga_filter
  ): [StakeBabyOoga!]!
  transfer(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transfer
  transferBatch(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TransferBatch
  transferBatches(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TransferBatch_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TransferBatch_filter
  ): [TransferBatch!]!
  transferSingle(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TransferSingle
  transferSingles(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TransferSingle_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TransferSingle_filter
  ): [TransferSingle!]!
  transfers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Transfer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Transfer_filter
  ): [Transfer!]!
  unstakeBabyOoga(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UnstakeBabyOoga
  unstakeBabyOogas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UnstakeBabyOoga_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UnstakeBabyOoga_filter
  ): [UnstakeBabyOoga!]!
  upgradeBox(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UpgradeBox
  upgradeBoxes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UpgradeBox_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UpgradeBox_filter
  ): [UpgradeBox!]!
  uri(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): URI
  uris(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: URI_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: URI_filter
  ): [URI!]!
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  userItemAmount(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserItemAmount
  userItemAmounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserItemAmount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserItemAmount_filter
  ): [UserItemAmount!]!
  userNTPouchAmount(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserNTPouchAmount
  userNTPouchAmounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserNTPouchAmount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserNTPouchAmount_filter
  ): [UserNTPouchAmount!]!
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
  withdrawPouch(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WithdrawPouch
  withdrawPouches(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: WithdrawPouch_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: WithdrawPouch_filter
  ): [WithdrawPouch!]!
  wonBoxFromMatch(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WonBoxFromMatch
  wonBoxFromMatches(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: WonBoxFromMatch_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: WonBoxFromMatch_filter
  ): [WonBoxFromMatch!]!
}

type RatingChange {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  newRating: BigInt!
  transactionHash: Bytes!
}

input RatingChange_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [RatingChange_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  newRating: BigInt
  newRating_gt: BigInt
  newRating_gte: BigInt
  newRating_in: [BigInt!]
  newRating_lt: BigInt
  newRating_lte: BigInt
  newRating_not: BigInt
  newRating_not_in: [BigInt!]
  or: [RatingChange_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum RatingChange_orderBy {
  blockNumber
  blockTimestamp
  crewId
  id
  newRating
  transactionHash
}

type RemoveCrew {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  transactionHash: Bytes!
  user: Bytes!
}

type RemoveCrewFromBucket {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  bucketIndex: BigInt!
  crewId: BigInt!
  id: Bytes!
  transactionHash: Bytes!
}

input RemoveCrewFromBucket_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [RemoveCrewFromBucket_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  bucketIndex: BigInt
  bucketIndex_gt: BigInt
  bucketIndex_gte: BigInt
  bucketIndex_in: [BigInt!]
  bucketIndex_lt: BigInt
  bucketIndex_lte: BigInt
  bucketIndex_not: BigInt
  bucketIndex_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [RemoveCrewFromBucket_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum RemoveCrewFromBucket_orderBy {
  blockNumber
  blockTimestamp
  bucketIndex
  crewId
  id
  transactionHash
}

input RemoveCrew_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [RemoveCrew_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [RemoveCrew_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  user: Bytes
  user_contains: Bytes
  user_gt: Bytes
  user_gte: Bytes
  user_in: [Bytes!]
  user_lt: Bytes
  user_lte: Bytes
  user_not: Bytes
  user_not_contains: Bytes
  user_not_in: [Bytes!]
}

enum RemoveCrew_orderBy {
  blockNumber
  blockTimestamp
  crewId
  id
  transactionHash
  user
}

type RemoveRoboFromCrew {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  roboId: BigInt!
  transactionHash: Bytes!
}

input RemoveRoboFromCrew_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [RemoveRoboFromCrew_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [RemoveRoboFromCrew_filter]
  roboId: BigInt
  roboId_gt: BigInt
  roboId_gte: BigInt
  roboId_in: [BigInt!]
  roboId_lt: BigInt
  roboId_lte: BigInt
  roboId_not: BigInt
  roboId_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum RemoveRoboFromCrew_orderBy {
  blockNumber
  blockTimestamp
  crewId
  id
  roboId
  transactionHash
}

type ResolveMatch {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  bucketIndex: BigInt!
  crewIdFirst: BigInt!
  crewIdSecond: BigInt!
  id: Bytes!
  transactionHash: Bytes!
  winCrewId: BigInt!
}

input ResolveMatch_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ResolveMatch_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  bucketIndex: BigInt
  bucketIndex_gt: BigInt
  bucketIndex_gte: BigInt
  bucketIndex_in: [BigInt!]
  bucketIndex_lt: BigInt
  bucketIndex_lte: BigInt
  bucketIndex_not: BigInt
  bucketIndex_not_in: [BigInt!]
  crewIdFirst: BigInt
  crewIdFirst_gt: BigInt
  crewIdFirst_gte: BigInt
  crewIdFirst_in: [BigInt!]
  crewIdFirst_lt: BigInt
  crewIdFirst_lte: BigInt
  crewIdFirst_not: BigInt
  crewIdFirst_not_in: [BigInt!]
  crewIdSecond: BigInt
  crewIdSecond_gt: BigInt
  crewIdSecond_gte: BigInt
  crewIdSecond_in: [BigInt!]
  crewIdSecond_lt: BigInt
  crewIdSecond_lte: BigInt
  crewIdSecond_not: BigInt
  crewIdSecond_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [ResolveMatch_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  winCrewId: BigInt
  winCrewId_gt: BigInt
  winCrewId_gte: BigInt
  winCrewId_in: [BigInt!]
  winCrewId_lt: BigInt
  winCrewId_lte: BigInt
  winCrewId_not: BigInt
  winCrewId_not_in: [BigInt!]
}

enum ResolveMatch_orderBy {
  blockNumber
  blockTimestamp
  bucketIndex
  crewIdFirst
  crewIdSecond
  id
  transactionHash
  winCrewId
}

type RoleAdminChanged {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  newAdminRole: Bytes!
  previousAdminRole: Bytes!
  role: Bytes!
  transactionHash: Bytes!
}

input RoleAdminChanged_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [RoleAdminChanged_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  newAdminRole: Bytes
  newAdminRole_contains: Bytes
  newAdminRole_gt: Bytes
  newAdminRole_gte: Bytes
  newAdminRole_in: [Bytes!]
  newAdminRole_lt: Bytes
  newAdminRole_lte: Bytes
  newAdminRole_not: Bytes
  newAdminRole_not_contains: Bytes
  newAdminRole_not_in: [Bytes!]
  or: [RoleAdminChanged_filter]
  previousAdminRole: Bytes
  previousAdminRole_contains: Bytes
  previousAdminRole_gt: Bytes
  previousAdminRole_gte: Bytes
  previousAdminRole_in: [Bytes!]
  previousAdminRole_lt: Bytes
  previousAdminRole_lte: Bytes
  previousAdminRole_not: Bytes
  previousAdminRole_not_contains: Bytes
  previousAdminRole_not_in: [Bytes!]
  role: Bytes
  role_contains: Bytes
  role_gt: Bytes
  role_gte: Bytes
  role_in: [Bytes!]
  role_lt: Bytes
  role_lte: Bytes
  role_not: Bytes
  role_not_contains: Bytes
  role_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum RoleAdminChanged_orderBy {
  blockNumber
  blockTimestamp
  id
  newAdminRole
  previousAdminRole
  role
  transactionHash
}

type RoleGranted {
  account: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  role: Bytes!
  sender: Bytes!
  transactionHash: Bytes!
}

input RoleGranted_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [RoleGranted_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [RoleGranted_filter]
  role: Bytes
  role_contains: Bytes
  role_gt: Bytes
  role_gte: Bytes
  role_in: [Bytes!]
  role_lt: Bytes
  role_lte: Bytes
  role_not: Bytes
  role_not_contains: Bytes
  role_not_in: [Bytes!]
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum RoleGranted_orderBy {
  account
  blockNumber
  blockTimestamp
  id
  role
  sender
  transactionHash
}

type RoleRevoked {
  account: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  role: Bytes!
  sender: Bytes!
  transactionHash: Bytes!
}

input RoleRevoked_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [RoleRevoked_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [RoleRevoked_filter]
  role: Bytes
  role_contains: Bytes
  role_gt: Bytes
  role_gte: Bytes
  role_in: [Bytes!]
  role_lt: Bytes
  role_lte: Bytes
  role_not: Bytes
  role_not_contains: Bytes
  role_not_in: [Bytes!]
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum RoleRevoked_orderBy {
  account
  blockNumber
  blockTimestamp
  id
  role
  sender
  transactionHash
}

type SetBucketRandomSeed {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  bucketIndex: BigInt!
  id: Bytes!
  randomSeed: BigInt!
  transactionHash: Bytes!
}

input SetBucketRandomSeed_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [SetBucketRandomSeed_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  bucketIndex: BigInt
  bucketIndex_gt: BigInt
  bucketIndex_gte: BigInt
  bucketIndex_in: [BigInt!]
  bucketIndex_lt: BigInt
  bucketIndex_lte: BigInt
  bucketIndex_not: BigInt
  bucketIndex_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [SetBucketRandomSeed_filter]
  randomSeed: BigInt
  randomSeed_gt: BigInt
  randomSeed_gte: BigInt
  randomSeed_in: [BigInt!]
  randomSeed_lt: BigInt
  randomSeed_lte: BigInt
  randomSeed_not: BigInt
  randomSeed_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum SetBucketRandomSeed_orderBy {
  blockNumber
  blockTimestamp
  bucketIndex
  id
  randomSeed
  transactionHash
}

type SetItemAttribute {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  itemId: BigInt!
  item_abilities: [Int]!
  item_attack: BigInt!
  item_health: BigInt!
  item_itemType: Int!
  item_level: BigInt!
  item_season: BigInt!
  transactionHash: Bytes!
}

input SetItemAttribute_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [SetItemAttribute_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  itemId: BigInt
  itemId_gt: BigInt
  itemId_gte: BigInt
  itemId_in: [BigInt!]
  itemId_lt: BigInt
  itemId_lte: BigInt
  itemId_not: BigInt
  itemId_not_in: [BigInt!]
  item_abilities: [Int!]
  item_abilities_contains: [Int!]
  item_abilities_contains_nocase: [Int!]
  item_abilities_not: [Int!]
  item_abilities_not_contains: [Int!]
  item_abilities_not_contains_nocase: [Int!]
  item_attack: BigInt
  item_attack_gt: BigInt
  item_attack_gte: BigInt
  item_attack_in: [BigInt!]
  item_attack_lt: BigInt
  item_attack_lte: BigInt
  item_attack_not: BigInt
  item_attack_not_in: [BigInt!]
  item_health: BigInt
  item_health_gt: BigInt
  item_health_gte: BigInt
  item_health_in: [BigInt!]
  item_health_lt: BigInt
  item_health_lte: BigInt
  item_health_not: BigInt
  item_health_not_in: [BigInt!]
  item_itemType: Int
  item_itemType_gt: Int
  item_itemType_gte: Int
  item_itemType_in: [Int!]
  item_itemType_lt: Int
  item_itemType_lte: Int
  item_itemType_not: Int
  item_itemType_not_in: [Int!]
  item_level: BigInt
  item_level_gt: BigInt
  item_level_gte: BigInt
  item_level_in: [BigInt!]
  item_level_lt: BigInt
  item_level_lte: BigInt
  item_level_not: BigInt
  item_level_not_in: [BigInt!]
  item_season: BigInt
  item_season_gt: BigInt
  item_season_gte: BigInt
  item_season_in: [BigInt!]
  item_season_lt: BigInt
  item_season_lte: BigInt
  item_season_not: BigInt
  item_season_not_in: [BigInt!]
  or: [SetItemAttribute_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum SetItemAttribute_orderBy {
  blockNumber
  blockTimestamp
  id
  itemId
  item_abilities
  item_attack
  item_health
  item_itemType
  item_level
  item_season
  transactionHash
}

type SetOogaAttribute {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  oogaId: BigInt!
  ooga_attack: BigInt!
  ooga_health: BigInt!
  ooga_level: Int!
  ooga_oogaType: Int!
  transactionHash: Bytes!
}

input SetOogaAttribute_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [SetOogaAttribute_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  oogaId: BigInt
  oogaId_gt: BigInt
  oogaId_gte: BigInt
  oogaId_in: [BigInt!]
  oogaId_lt: BigInt
  oogaId_lte: BigInt
  oogaId_not: BigInt
  oogaId_not_in: [BigInt!]
  ooga_attack: BigInt
  ooga_attack_gt: BigInt
  ooga_attack_gte: BigInt
  ooga_attack_in: [BigInt!]
  ooga_attack_lt: BigInt
  ooga_attack_lte: BigInt
  ooga_attack_not: BigInt
  ooga_attack_not_in: [BigInt!]
  ooga_health: BigInt
  ooga_health_gt: BigInt
  ooga_health_gte: BigInt
  ooga_health_in: [BigInt!]
  ooga_health_lt: BigInt
  ooga_health_lte: BigInt
  ooga_health_not: BigInt
  ooga_health_not_in: [BigInt!]
  ooga_level: Int
  ooga_level_gt: Int
  ooga_level_gte: Int
  ooga_level_in: [Int!]
  ooga_level_lt: Int
  ooga_level_lte: Int
  ooga_level_not: Int
  ooga_level_not_in: [Int!]
  ooga_oogaType: Int
  ooga_oogaType_gt: Int
  ooga_oogaType_gte: Int
  ooga_oogaType_in: [Int!]
  ooga_oogaType_lt: Int
  ooga_oogaType_lte: Int
  ooga_oogaType_not: Int
  ooga_oogaType_not_in: [Int!]
  or: [SetOogaAttribute_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum SetOogaAttribute_orderBy {
  blockNumber
  blockTimestamp
  id
  oogaId
  ooga_attack
  ooga_health
  ooga_level
  ooga_oogaType
  transactionHash
}

type SetPouchAttribute {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  pouchAttributes_active: Boolean!
  pouchAttributes_amount: BigInt!
  pouchId: BigInt!
  transactionHash: Bytes!
}

input SetPouchAttribute_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [SetPouchAttribute_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [SetPouchAttribute_filter]
  pouchAttributes_active: Boolean
  pouchAttributes_active_in: [Boolean!]
  pouchAttributes_active_not: Boolean
  pouchAttributes_active_not_in: [Boolean!]
  pouchAttributes_amount: BigInt
  pouchAttributes_amount_gt: BigInt
  pouchAttributes_amount_gte: BigInt
  pouchAttributes_amount_in: [BigInt!]
  pouchAttributes_amount_lt: BigInt
  pouchAttributes_amount_lte: BigInt
  pouchAttributes_amount_not: BigInt
  pouchAttributes_amount_not_in: [BigInt!]
  pouchId: BigInt
  pouchId_gt: BigInt
  pouchId_gte: BigInt
  pouchId_in: [BigInt!]
  pouchId_lt: BigInt
  pouchId_lte: BigInt
  pouchId_not: BigInt
  pouchId_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum SetPouchAttribute_orderBy {
  blockNumber
  blockTimestamp
  id
  pouchAttributes_active
  pouchAttributes_amount
  pouchId
  transactionHash
}

type StakeBabyOoga {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  oogaId: BigInt!
  slotIndex: BigInt!
  transactionHash: Bytes!
}

input StakeBabyOoga_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [StakeBabyOoga_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  oogaId: BigInt
  oogaId_gt: BigInt
  oogaId_gte: BigInt
  oogaId_in: [BigInt!]
  oogaId_lt: BigInt
  oogaId_lte: BigInt
  oogaId_not: BigInt
  oogaId_not_in: [BigInt!]
  or: [StakeBabyOoga_filter]
  slotIndex: BigInt
  slotIndex_gt: BigInt
  slotIndex_gte: BigInt
  slotIndex_in: [BigInt!]
  slotIndex_lt: BigInt
  slotIndex_lte: BigInt
  slotIndex_not: BigInt
  slotIndex_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum StakeBabyOoga_orderBy {
  blockNumber
  blockTimestamp
  crewId
  id
  oogaId
  slotIndex
  transactionHash
}

type Subscription {
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
  addCrewToBucket(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AddCrewToBucket
  addCrewToBuckets(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AddCrewToBucket_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AddCrewToBucket_filter
  ): [AddCrewToBucket!]!
  addItemToInventories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AddItemToInventory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AddItemToInventory_filter
  ): [AddItemToInventory!]!
  addItemToInventory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AddItemToInventory
  addRoboToCrew(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AddRoboToCrew
  addRoboToCrews(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AddRoboToCrew_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AddRoboToCrew_filter
  ): [AddRoboToCrew!]!
  approval(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Approval
  approvalForAll(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ApprovalForAll
  approvalForAlls(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ApprovalForAll_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ApprovalForAll_filter
  ): [ApprovalForAll!]!
  approvals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Approval_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Approval_filter
  ): [Approval!]!
  boxInitialized(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BoxInitialized
  boxInitializeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BoxInitialized_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BoxInitialized_filter
  ): [BoxInitialized!]!
  boxOpened(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BoxOpened
  boxOpeneds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BoxOpened_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BoxOpened_filter
  ): [BoxOpened!]!
  boxRoleAdminChanged(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BoxRoleAdminChanged
  boxRoleAdminChangeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BoxRoleAdminChanged_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BoxRoleAdminChanged_filter
  ): [BoxRoleAdminChanged!]!
  boxRoleGranted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BoxRoleGranted
  boxRoleGranteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BoxRoleGranted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BoxRoleGranted_filter
  ): [BoxRoleGranted!]!
  boxRoleRevoked(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BoxRoleRevoked
  boxRoleRevokeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BoxRoleRevoked_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BoxRoleRevoked_filter
  ): [BoxRoleRevoked!]!
  boxSlot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BoxSlot
  boxSlots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BoxSlot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BoxSlot_filter
  ): [BoxSlot!]!
  boxUpgraded(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BoxUpgraded
  boxUpgradeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BoxUpgraded_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BoxUpgraded_filter
  ): [BoxUpgraded!]!
  bucket(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Bucket
  buckets(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Bucket_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Bucket_filter
  ): [Bucket!]!
  buyMysteryBox(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BuyMysteryBox
  buyMysteryBoxes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BuyMysteryBox_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BuyMysteryBox_filter
  ): [BuyMysteryBox!]!
  changeBucketState(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ChangeBucketState
  changeBucketStates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ChangeBucketState_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ChangeBucketState_filter
  ): [ChangeBucketState!]!
  contractParameter(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ContractParameter
  contractParameters(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ContractParameter_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ContractParameter_filter
  ): [ContractParameter!]!
  crew(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Crew
  crewInBucket(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CrewInBucket
  crewInBuckets(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CrewInBucket_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CrewInBucket_filter
  ): [CrewInBucket!]!
  crews(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Crew_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Crew_filter
  ): [Crew!]!
  crewsInitialized(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CrewsInitialized
  crewsInitializeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CrewsInitialized_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CrewsInitialized_filter
  ): [CrewsInitialized!]!
  crewsRoleAdminChanged(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CrewsRoleAdminChanged
  crewsRoleAdminChangeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CrewsRoleAdminChanged_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CrewsRoleAdminChanged_filter
  ): [CrewsRoleAdminChanged!]!
  crewsRoleGranted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CrewsRoleGranted
  crewsRoleGranteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CrewsRoleGranted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CrewsRoleGranted_filter
  ): [CrewsRoleGranted!]!
  crewsRoleRevoked(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CrewsRoleRevoked
  crewsRoleRevokeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CrewsRoleRevoked_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CrewsRoleRevoked_filter
  ): [CrewsRoleRevoked!]!
  deleteItemToInventories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DeleteItemToInventory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DeleteItemToInventory_filter
  ): [DeleteItemToInventory!]!
  deleteItemToInventory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DeleteItemToInventory
  depositPouch(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DepositPouch
  depositPouches(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DepositPouch_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DepositPouch_filter
  ): [DepositPouch!]!
  durabilityChange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DurabilityChange
  durabilityChanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DurabilityChange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DurabilityChange_filter
  ): [DurabilityChange!]!
  equipItemToOoga(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): EquipItemToOoga
  equipItemToOogas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: EquipItemToOoga_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: EquipItemToOoga_filter
  ): [EquipItemToOoga!]!
  equipSpecialItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): EquipSpecialItem
  equipSpecialItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: EquipSpecialItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: EquipSpecialItem_filter
  ): [EquipSpecialItem!]!
  initialized(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Initialized
  initializeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Initialized_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Initialized_filter
  ): [Initialized!]!
  inventoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): InventoryItem
  inventoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: InventoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: InventoryItem_filter
  ): [InventoryItem!]!
  item(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Item
  items(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Item_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Item_filter
  ): [Item!]!
  levelChange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LevelChange
  levelChanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LevelChange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LevelChange_filter
  ): [LevelChange!]!
  makeNewCrew(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MakeNewCrew
  makeNewCrews(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MakeNewCrew_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MakeNewCrew_filter
  ): [MakeNewCrew!]!
  match(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Match
  matches(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Match_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Match_filter
  ): [Match!]!
  matchmakingInitialized(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MatchmakingInitialized
  matchmakingInitializeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MatchmakingInitialized_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MatchmakingInitialized_filter
  ): [MatchmakingInitialized!]!
  matchmakingRoleAdminChanged(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MatchmakingRoleAdminChanged
  matchmakingRoleAdminChangeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MatchmakingRoleAdminChanged_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MatchmakingRoleAdminChanged_filter
  ): [MatchmakingRoleAdminChanged!]!
  matchmakingRoleGranted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MatchmakingRoleGranted
  matchmakingRoleGranteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MatchmakingRoleGranted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MatchmakingRoleGranted_filter
  ): [MatchmakingRoleGranted!]!
  matchmakingRoleRevoked(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MatchmakingRoleRevoked
  matchmakingRoleRevokeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MatchmakingRoleRevoked_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MatchmakingRoleRevoked_filter
  ): [MatchmakingRoleRevoked!]!
  mekawarsItemsApprovalForAll(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MekawarsItemsApprovalForAll
  mekawarsItemsApprovalForAlls(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MekawarsItemsApprovalForAll_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MekawarsItemsApprovalForAll_filter
  ): [MekawarsItemsApprovalForAll!]!
  mekawarsItemsInitialized(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MekawarsItemsInitialized
  mekawarsItemsInitializeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MekawarsItemsInitialized_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MekawarsItemsInitialized_filter
  ): [MekawarsItemsInitialized!]!
  mekawarsItemsRoleAdminChanged(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MekawarsItemsRoleAdminChanged
  mekawarsItemsRoleAdminChangeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MekawarsItemsRoleAdminChanged_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MekawarsItemsRoleAdminChanged_filter
  ): [MekawarsItemsRoleAdminChanged!]!
  mekawarsItemsRoleGranted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MekawarsItemsRoleGranted
  mekawarsItemsRoleGranteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MekawarsItemsRoleGranted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MekawarsItemsRoleGranted_filter
  ): [MekawarsItemsRoleGranted!]!
  mekawarsItemsRoleRevoked(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MekawarsItemsRoleRevoked
  mekawarsItemsRoleRevokeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MekawarsItemsRoleRevoked_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MekawarsItemsRoleRevoked_filter
  ): [MekawarsItemsRoleRevoked!]!
  mysteryBoxOpened(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MysteryBoxOpened
  mysteryBoxOpeneds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MysteryBoxOpened_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MysteryBoxOpened_filter
  ): [MysteryBoxOpened!]!
  newBucket(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewBucket
  newBuckets(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NewBucket_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NewBucket_filter
  ): [NewBucket!]!
  newFirstTeam(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewFirstTeam
  newFirstTeams(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NewFirstTeam_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NewFirstTeam_filter
  ): [NewFirstTeam!]!
  ntchange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTChange
  ntchanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTChange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTChange_filter
  ): [NTChange!]!
  ntpouch(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTPouch
  ntpouchApprovalForAll(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTPouchApprovalForAll
  ntpouchApprovalForAlls(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTPouchApprovalForAll_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTPouchApprovalForAll_filter
  ): [NTPouchApprovalForAll!]!
  ntpouchInitialized(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTPouchInitialized
  ntpouchInitializeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTPouchInitialized_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTPouchInitialized_filter
  ): [NTPouchInitialized!]!
  ntpouchRoleAdminChanged(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTPouchRoleAdminChanged
  ntpouchRoleAdminChangeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTPouchRoleAdminChanged_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTPouchRoleAdminChanged_filter
  ): [NTPouchRoleAdminChanged!]!
  ntpouchRoleGranted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTPouchRoleGranted
  ntpouchRoleGranteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTPouchRoleGranted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTPouchRoleGranted_filter
  ): [NTPouchRoleGranted!]!
  ntpouchRoleRevoked(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTPouchRoleRevoked
  ntpouchRoleRevokeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTPouchRoleRevoked_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTPouchRoleRevoked_filter
  ): [NTPouchRoleRevoked!]!
  ntpouchTransferBatch(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTPouchTransferBatch
  ntpouchTransferBatches(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTPouchTransferBatch_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTPouchTransferBatch_filter
  ): [NTPouchTransferBatch!]!
  ntpouchTransferSingle(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTPouchTransferSingle
  ntpouchTransferSingles(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTPouchTransferSingle_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTPouchTransferSingle_filter
  ): [NTPouchTransferSingle!]!
  ntpouchURI(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTPouchURI
  ntpouchURIs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTPouchURI_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTPouchURI_filter
  ): [NTPouchURI!]!
  ntpouches(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NTPouch_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NTPouch_filter
  ): [NTPouch!]!
  ooga(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Ooga
  oogas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Ooga_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Ooga_filter
  ): [Ooga!]!
  openBox(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OpenBox
  openBoxes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OpenBox_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OpenBox_filter
  ): [OpenBox!]!
  ratingChange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RatingChange
  ratingChanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RatingChange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RatingChange_filter
  ): [RatingChange!]!
  removeCrew(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RemoveCrew
  removeCrewFromBucket(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RemoveCrewFromBucket
  removeCrewFromBuckets(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RemoveCrewFromBucket_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RemoveCrewFromBucket_filter
  ): [RemoveCrewFromBucket!]!
  removeCrews(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RemoveCrew_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RemoveCrew_filter
  ): [RemoveCrew!]!
  removeRoboFromCrew(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RemoveRoboFromCrew
  removeRoboFromCrews(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RemoveRoboFromCrew_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RemoveRoboFromCrew_filter
  ): [RemoveRoboFromCrew!]!
  resolveMatch(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ResolveMatch
  resolveMatches(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ResolveMatch_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ResolveMatch_filter
  ): [ResolveMatch!]!
  roleAdminChanged(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RoleAdminChanged
  roleAdminChangeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RoleAdminChanged_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RoleAdminChanged_filter
  ): [RoleAdminChanged!]!
  roleGranted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RoleGranted
  roleGranteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RoleGranted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RoleGranted_filter
  ): [RoleGranted!]!
  roleRevoked(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RoleRevoked
  roleRevokeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RoleRevoked_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RoleRevoked_filter
  ): [RoleRevoked!]!
  setBucketRandomSeed(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetBucketRandomSeed
  setBucketRandomSeeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SetBucketRandomSeed_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SetBucketRandomSeed_filter
  ): [SetBucketRandomSeed!]!
  setItemAttribute(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetItemAttribute
  setItemAttributes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SetItemAttribute_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SetItemAttribute_filter
  ): [SetItemAttribute!]!
  setOogaAttribute(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetOogaAttribute
  setOogaAttributes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SetOogaAttribute_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SetOogaAttribute_filter
  ): [SetOogaAttribute!]!
  setPouchAttribute(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetPouchAttribute
  setPouchAttributes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SetPouchAttribute_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SetPouchAttribute_filter
  ): [SetPouchAttribute!]!
  stakeBabyOoga(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeBabyOoga
  stakeBabyOogas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StakeBabyOoga_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StakeBabyOoga_filter
  ): [StakeBabyOoga!]!
  transfer(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transfer
  transferBatch(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TransferBatch
  transferBatches(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TransferBatch_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TransferBatch_filter
  ): [TransferBatch!]!
  transferSingle(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TransferSingle
  transferSingles(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TransferSingle_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TransferSingle_filter
  ): [TransferSingle!]!
  transfers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Transfer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Transfer_filter
  ): [Transfer!]!
  unstakeBabyOoga(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UnstakeBabyOoga
  unstakeBabyOogas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UnstakeBabyOoga_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UnstakeBabyOoga_filter
  ): [UnstakeBabyOoga!]!
  upgradeBox(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UpgradeBox
  upgradeBoxes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UpgradeBox_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UpgradeBox_filter
  ): [UpgradeBox!]!
  uri(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): URI
  uris(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: URI_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: URI_filter
  ): [URI!]!
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  userItemAmount(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserItemAmount
  userItemAmounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserItemAmount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserItemAmount_filter
  ): [UserItemAmount!]!
  userNTPouchAmount(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserNTPouchAmount
  userNTPouchAmounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserNTPouchAmount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserNTPouchAmount_filter
  ): [UserNTPouchAmount!]!
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
  withdrawPouch(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WithdrawPouch
  withdrawPouches(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: WithdrawPouch_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: WithdrawPouch_filter
  ): [WithdrawPouch!]!
  wonBoxFromMatch(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WonBoxFromMatch
  wonBoxFromMatches(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: WonBoxFromMatch_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: WonBoxFromMatch_filter
  ): [WonBoxFromMatch!]!
}

type Transfer {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  from: Bytes!
  id: Bytes!
  to: Bytes!
  tokenId: BigInt!
  transactionHash: Bytes!
}

type TransferBatch {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  from: Bytes!
  id: Bytes!
  ids: [BigInt!]!
  operator: Bytes!
  to: Bytes!
  transactionHash: Bytes!
  values: [BigInt!]!
}

input TransferBatch_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [TransferBatch_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  from: Bytes
  from_contains: Bytes
  from_gt: Bytes
  from_gte: Bytes
  from_in: [Bytes!]
  from_lt: Bytes
  from_lte: Bytes
  from_not: Bytes
  from_not_contains: Bytes
  from_not_in: [Bytes!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  ids: [BigInt!]
  ids_contains: [BigInt!]
  ids_contains_nocase: [BigInt!]
  ids_not: [BigInt!]
  ids_not_contains: [BigInt!]
  ids_not_contains_nocase: [BigInt!]
  operator: Bytes
  operator_contains: Bytes
  operator_gt: Bytes
  operator_gte: Bytes
  operator_in: [Bytes!]
  operator_lt: Bytes
  operator_lte: Bytes
  operator_not: Bytes
  operator_not_contains: Bytes
  operator_not_in: [Bytes!]
  or: [TransferBatch_filter]
  to: Bytes
  to_contains: Bytes
  to_gt: Bytes
  to_gte: Bytes
  to_in: [Bytes!]
  to_lt: Bytes
  to_lte: Bytes
  to_not: Bytes
  to_not_contains: Bytes
  to_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  values: [BigInt!]
  values_contains: [BigInt!]
  values_contains_nocase: [BigInt!]
  values_not: [BigInt!]
  values_not_contains: [BigInt!]
  values_not_contains_nocase: [BigInt!]
}

enum TransferBatch_orderBy {
  blockNumber
  blockTimestamp
  from
  id
  ids
  operator
  to
  transactionHash
  values
}

type TransferSingle {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  from: Bytes!
  id: Bytes!
  operator: Bytes!
  to: Bytes!
  tokenId: BigInt!
  transactionHash: Bytes!
  value: BigInt!
}

input TransferSingle_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [TransferSingle_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  from: Bytes
  from_contains: Bytes
  from_gt: Bytes
  from_gte: Bytes
  from_in: [Bytes!]
  from_lt: Bytes
  from_lte: Bytes
  from_not: Bytes
  from_not_contains: Bytes
  from_not_in: [Bytes!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  operator: Bytes
  operator_contains: Bytes
  operator_gt: Bytes
  operator_gte: Bytes
  operator_in: [Bytes!]
  operator_lt: Bytes
  operator_lte: Bytes
  operator_not: Bytes
  operator_not_contains: Bytes
  operator_not_in: [Bytes!]
  or: [TransferSingle_filter]
  to: Bytes
  to_contains: Bytes
  to_gt: Bytes
  to_gte: Bytes
  to_in: [Bytes!]
  to_lt: Bytes
  to_lte: Bytes
  to_not: Bytes
  to_not_contains: Bytes
  to_not_in: [Bytes!]
  tokenId: BigInt
  tokenId_gt: BigInt
  tokenId_gte: BigInt
  tokenId_in: [BigInt!]
  tokenId_lt: BigInt
  tokenId_lte: BigInt
  tokenId_not: BigInt
  tokenId_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum TransferSingle_orderBy {
  blockNumber
  blockTimestamp
  from
  id
  operator
  to
  tokenId
  transactionHash
  value
}

input Transfer_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Transfer_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  from: Bytes
  from_contains: Bytes
  from_gt: Bytes
  from_gte: Bytes
  from_in: [Bytes!]
  from_lt: Bytes
  from_lte: Bytes
  from_not: Bytes
  from_not_contains: Bytes
  from_not_in: [Bytes!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [Transfer_filter]
  to: Bytes
  to_contains: Bytes
  to_gt: Bytes
  to_gte: Bytes
  to_in: [Bytes!]
  to_lt: Bytes
  to_lte: Bytes
  to_not: Bytes
  to_not_contains: Bytes
  to_not_in: [Bytes!]
  tokenId: BigInt
  tokenId_gt: BigInt
  tokenId_gte: BigInt
  tokenId_in: [BigInt!]
  tokenId_lt: BigInt
  tokenId_lte: BigInt
  tokenId_not: BigInt
  tokenId_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum Transfer_orderBy {
  blockNumber
  blockTimestamp
  from
  id
  to
  tokenId
  transactionHash
}

type URI {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  tokenId: BigInt!
  transactionHash: Bytes!
  value: String!
}

input URI_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [URI_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [URI_filter]
  tokenId: BigInt
  tokenId_gt: BigInt
  tokenId_gte: BigInt
  tokenId_in: [BigInt!]
  tokenId_lt: BigInt
  tokenId_lte: BigInt
  tokenId_not: BigInt
  tokenId_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: String
  value_contains: String
  value_contains_nocase: String
  value_ends_with: String
  value_ends_with_nocase: String
  value_gt: String
  value_gte: String
  value_in: [String!]
  value_lt: String
  value_lte: String
  value_not: String
  value_not_contains: String
  value_not_contains_nocase: String
  value_not_ends_with: String
  value_not_ends_with_nocase: String
  value_not_in: [String!]
  value_not_starts_with: String
  value_not_starts_with_nocase: String
  value_starts_with: String
  value_starts_with_nocase: String
}

enum URI_orderBy {
  blockNumber
  blockTimestamp
  id
  tokenId
  transactionHash
  value
}

type UnstakeBabyOoga {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  oogaId: BigInt!
  slotIndex: BigInt!
  transactionHash: Bytes!
}

input UnstakeBabyOoga_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [UnstakeBabyOoga_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  oogaId: BigInt
  oogaId_gt: BigInt
  oogaId_gte: BigInt
  oogaId_in: [BigInt!]
  oogaId_lt: BigInt
  oogaId_lte: BigInt
  oogaId_not: BigInt
  oogaId_not_in: [BigInt!]
  or: [UnstakeBabyOoga_filter]
  slotIndex: BigInt
  slotIndex_gt: BigInt
  slotIndex_gte: BigInt
  slotIndex_in: [BigInt!]
  slotIndex_lt: BigInt
  slotIndex_lte: BigInt
  slotIndex_not: BigInt
  slotIndex_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum UnstakeBabyOoga_orderBy {
  blockNumber
  blockTimestamp
  crewId
  id
  oogaId
  slotIndex
  transactionHash
}

type UpgradeBox {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  newBabyOogaCharge: BigInt!
  newSlotState: Int!
  slotIndex: BigInt!
  transactionHash: Bytes!
}

input UpgradeBox_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [UpgradeBox_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  newBabyOogaCharge: BigInt
  newBabyOogaCharge_gt: BigInt
  newBabyOogaCharge_gte: BigInt
  newBabyOogaCharge_in: [BigInt!]
  newBabyOogaCharge_lt: BigInt
  newBabyOogaCharge_lte: BigInt
  newBabyOogaCharge_not: BigInt
  newBabyOogaCharge_not_in: [BigInt!]
  newSlotState: Int
  newSlotState_gt: Int
  newSlotState_gte: Int
  newSlotState_in: [Int!]
  newSlotState_lt: Int
  newSlotState_lte: Int
  newSlotState_not: Int
  newSlotState_not_in: [Int!]
  or: [UpgradeBox_filter]
  slotIndex: BigInt
  slotIndex_gt: BigInt
  slotIndex_gte: BigInt
  slotIndex_in: [BigInt!]
  slotIndex_lt: BigInt
  slotIndex_lte: BigInt
  slotIndex_not: BigInt
  slotIndex_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum UpgradeBox_orderBy {
  blockNumber
  blockTimestamp
  crewId
  id
  newBabyOogaCharge
  newSlotState
  slotIndex
  transactionHash
}

type User {
  crews(
    first: Int = 100
    orderBy: Crew_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Crew_filter
  ): [Crew!]!
  id: Bytes!
  itemAmounts(
    first: Int = 100
    orderBy: UserItemAmount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: UserItemAmount_filter
  ): [UserItemAmount!]!
  notStakedOogas(
    first: Int = 100
    orderBy: Ooga_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Ooga_filter
  ): [Ooga!]!
  ntPouchAmounts(
    first: Int = 100
    orderBy: UserNTPouchAmount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: UserNTPouchAmount_filter
  ): [UserNTPouchAmount!]!
}

type UserItemAmount {
  amount: BigInt
  id: Bytes!
  item: Item
  user: User
}

input UserItemAmount_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  and: [UserItemAmount_filter]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  item: String
  item_: Item_filter
  item_contains: String
  item_contains_nocase: String
  item_ends_with: String
  item_ends_with_nocase: String
  item_gt: String
  item_gte: String
  item_in: [String!]
  item_lt: String
  item_lte: String
  item_not: String
  item_not_contains: String
  item_not_contains_nocase: String
  item_not_ends_with: String
  item_not_ends_with_nocase: String
  item_not_in: [String!]
  item_not_starts_with: String
  item_not_starts_with_nocase: String
  item_starts_with: String
  item_starts_with_nocase: String
  or: [UserItemAmount_filter]
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum UserItemAmount_orderBy {
  amount
  id
  item
  user
}

type UserNTPouchAmount {
  amount: BigInt
  id: Bytes!
  ntPouch: NTPouch
  user: User
}

input UserNTPouchAmount_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  and: [UserNTPouchAmount_filter]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  ntPouch: String
  ntPouch_: NTPouch_filter
  ntPouch_contains: String
  ntPouch_contains_nocase: String
  ntPouch_ends_with: String
  ntPouch_ends_with_nocase: String
  ntPouch_gt: String
  ntPouch_gte: String
  ntPouch_in: [String!]
  ntPouch_lt: String
  ntPouch_lte: String
  ntPouch_not: String
  ntPouch_not_contains: String
  ntPouch_not_contains_nocase: String
  ntPouch_not_ends_with: String
  ntPouch_not_ends_with_nocase: String
  ntPouch_not_in: [String!]
  ntPouch_not_starts_with: String
  ntPouch_not_starts_with_nocase: String
  ntPouch_starts_with: String
  ntPouch_starts_with_nocase: String
  or: [UserNTPouchAmount_filter]
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum UserNTPouchAmount_orderBy {
  amount
  id
  ntPouch
  user
}

input User_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [User_filter]
  crews_: Crew_filter
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  itemAmounts_: UserItemAmount_filter
  notStakedOogas_: Ooga_filter
  ntPouchAmounts_: UserNTPouchAmount_filter
  or: [User_filter]
}

enum User_orderBy {
  crews
  id
  itemAmounts
  notStakedOogas
  ntPouchAmounts
}

type WithdrawPouch {
  amount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  crewId: BigInt!
  id: Bytes!
  pouchId: BigInt!
  transactionHash: Bytes!
}

input WithdrawPouch_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  and: [WithdrawPouch_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [WithdrawPouch_filter]
  pouchId: BigInt
  pouchId_gt: BigInt
  pouchId_gte: BigInt
  pouchId_in: [BigInt!]
  pouchId_lt: BigInt
  pouchId_lte: BigInt
  pouchId_not: BigInt
  pouchId_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum WithdrawPouch_orderBy {
  amount
  blockNumber
  blockTimestamp
  crewId
  id
  pouchId
  transactionHash
}

type WonBoxFromMatch {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  box_createdAt: BigInt!
  box_level: BigInt!
  box_rarity: Int!
  crewId: BigInt!
  id: Bytes!
  newBabyOogaCharge: BigInt!
  slotIndex: BigInt!
  transactionHash: Bytes!
}

input WonBoxFromMatch_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [WonBoxFromMatch_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  box_createdAt: BigInt
  box_createdAt_gt: BigInt
  box_createdAt_gte: BigInt
  box_createdAt_in: [BigInt!]
  box_createdAt_lt: BigInt
  box_createdAt_lte: BigInt
  box_createdAt_not: BigInt
  box_createdAt_not_in: [BigInt!]
  box_level: BigInt
  box_level_gt: BigInt
  box_level_gte: BigInt
  box_level_in: [BigInt!]
  box_level_lt: BigInt
  box_level_lte: BigInt
  box_level_not: BigInt
  box_level_not_in: [BigInt!]
  box_rarity: Int
  box_rarity_gt: Int
  box_rarity_gte: Int
  box_rarity_in: [Int!]
  box_rarity_lt: Int
  box_rarity_lte: Int
  box_rarity_not: Int
  box_rarity_not_in: [Int!]
  crewId: BigInt
  crewId_gt: BigInt
  crewId_gte: BigInt
  crewId_in: [BigInt!]
  crewId_lt: BigInt
  crewId_lte: BigInt
  crewId_not: BigInt
  crewId_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  newBabyOogaCharge: BigInt
  newBabyOogaCharge_gt: BigInt
  newBabyOogaCharge_gte: BigInt
  newBabyOogaCharge_in: [BigInt!]
  newBabyOogaCharge_lt: BigInt
  newBabyOogaCharge_lte: BigInt
  newBabyOogaCharge_not: BigInt
  newBabyOogaCharge_not_in: [BigInt!]
  or: [WonBoxFromMatch_filter]
  slotIndex: BigInt
  slotIndex_gt: BigInt
  slotIndex_gte: BigInt
  slotIndex_in: [BigInt!]
  slotIndex_lt: BigInt
  slotIndex_lte: BigInt
  slotIndex_not: BigInt
  slotIndex_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum WonBoxFromMatch_orderBy {
  blockNumber
  blockTimestamp
  box_createdAt
  box_level
  box_rarity
  crewId
  id
  newBabyOogaCharge
  slotIndex
  transactionHash
}

type _Block_ {
  """
  The hash of the block
  """
  hash: Bytes

  """
  The block number
  """
  number: Int!

  """
  Integer representation of the timestamp stored in blocks for the chain
  """
  timestamp: Int
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
  "Information about a specific subgraph block. The hash of the block\nwill be null if the _meta field has a block constraint that asks for\na block number. It will be filled if the _meta field has no block constraint\nand therefore asks for the latest  block\n"
  block: _Block_!

  """
  The deployment ID
  """
  deployment: String!

  """
  If `true`, the subgraph encountered indexing errors at some past block
  """
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """
  Data will be returned even if the subgraph has indexing errors
  """
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}
